# import shioaji_patch  # Optional: Enable this if you encounter IndexError in fetch_contracts
import time
import uuid
import logging
import os
import threading
import json
import sys
from enum import Enum, auto
from typing import Dict, List, Optional, Any, Tuple, Callable
from dataclasses import dataclass, field
import traceback
from dotenv import load_dotenv

import shioaji as sj
from shioaji import constant as sj_constant
import ssl
import math

# --- SSL Context Hack for macOS ---
try:
    _create_unverified_https_context = ssl._create_unverified_context
except AttributeError:
    pass
else:
    ssl._create_default_https_context = _create_unverified_https_context
# ----------------------------------

# ============================================================
# ROBUST CONTRACT RESOLVERS (Fix: Futures contract lookup/sub)
# ============================================================

def resolve_stock_contract(api: sj.Shioaji, code: str):
    """
    Robust stock contract resolver.
    """
    try:
        c = api.Contracts.Stocks.get(code)
        if c:
            return c
    except Exception:
        pass
    try:
        return api.Contracts.Stocks[code]
    except Exception:
        return None


def _iter_contract_container(container):
    """
    Best-effort iterator over Shioaji contract container nodes.
    Yields contract objects that have attribute 'code'.
    """
    # If container itself is a contract
    if container is None:
        return
    if hasattr(container, "code") and getattr(container, "code", ""):
        yield container
        return

    # dict-like
    try:
        keys = list(container.keys())
    except Exception:
        keys = None

    if keys is not None:
        for k in keys:
            try:
                v = container.get(k)
            except Exception:
                v = None
            if v is None:
                continue
            # Some nested dict-like nodes
            yield from _iter_contract_container(v)
        return

    # iterable-like
    try:
        for item in container:
            # Some are tuples (name, contract)
            if isinstance(item, tuple) and len(item) >= 2:
                item = item[1]
            if item is None:
                continue
            yield from _iter_contract_container(item)
    except Exception:
        return


def iter_future_contracts(api: sj.Shioaji):
    """
    Iterate all future contracts (futures only) in Shioaji Contracts tree.
    """
    fut_root = api.Contracts.Futures
    # Common: Futures has attributes like TAIEX / something; walk all public attrs
    for name in dir(fut_root):
        if name.startswith("_"):
            continue
        node = getattr(fut_root, name, None)
        if node is None:
            continue
        # Skip methods/functions
        if callable(node):
            continue
        yield from _iter_contract_container(node)


def resolve_future_contract(api: sj.Shioaji, code: str):
    """
    Robust future contract resolver by walking the contract tree.
    """
    fut_root = api.Contracts.Futures

    # 1) direct .get if supported
    try:
        c = fut_root.get(code)
        if c:
            return c
    except Exception:
        pass

    # 2) full walk
    for c in iter_future_contracts(api):
        try:
            if getattr(c, "code", "") == code:
                return c
        except Exception:
            pass

    return None


# --- Configuration & Enums ---

class TransactionState(Enum):
    INIT = auto()               # Created
    LEG1_SUBMITTED = auto()     # Stock order sent
    LEG1_PARTIAL = auto()       # Stock partially filled
    LEG1_FILLED = auto()        # Stock fully filled
    LEG2_SUBMITTED = auto()     # Future order sent
    LEG2_PARTIAL = auto()       # Future partially filled
    LEG2_FILLED = auto()        # Future fully filled
    COMPLETED = auto()          # Both legs filled
    CANCELLING = auto()         # Cancellation in progress
    CANCELLED = auto()          # Transaction cancelled
    FAILED = auto()             # Fatal error (requires manual intervention)

class SignalType(Enum):
    OPEN = auto()
    CLOSE = auto()
    REPAIR = auto()

@dataclass
class TradeIntent:
    """
    Generated by Strategy, consumed by TxManager.
    """
    type: SignalType
    stock_code: str
    future_code: str
    qty: int
    is_force: bool = False
    details: str = ""

@dataclass
class OrderStub:
    """
    Represents an order within a Transaction.
    Tracks the internal state and the exchange Order ID.
    """
    order_id: str = ""
    seqno: str = ""
    status: str = "INIT"  # Submitted, Filled, Cancelled, Failed
    filled_qty: int = 0
    price: float = 0.0
    action: str = ""
    error_msg: str = ""
    last_deal_qty_reported: int = 0

def _get_deal_qty(status: Dict) -> int:
    """Robustly extract deal quantity."""
    for k in ("deal_quantity", "deal_qty", "filled_qty", "dealQuantity"):
        v = status.get(k, None)
        if v is not None:
            try: return int(v)
            except: pass
    return 0

def _apply_fill(order: OrderStub, status_data: Dict) -> int:
    q = _get_deal_qty(status_data)
    delta = 0
    # Shioaji 'deal_quantity' is usually cumulative in OrderState.
    # If q is >= last_reported, treat as cumulative update.
    if q >= order.last_deal_qty_reported:
        delta = q - order.last_deal_qty_reported
        order.last_deal_qty_reported = q
        order.filled_qty += delta
    else:
        # q < last reported. This might be an incremental 'Deal' event or a reset?
        # Safe fallback: treat as incremental if small positive?
        # For now, ignore to avoid double counting if status is mixed.
        pass
    return delta

# --- Market Data & Strategy ---

@dataclass
class MarketSnapshot:
    code: str
    price: float = 0.0
    bid: float = 0.0
    ask: float = 0.0
    ts: float = 0.0
    volume: int = 0

class StrategyState:
    """
    Tracks EWMA statistics for a specific Pair.
    """
    def __init__(self, half_life_sec: float = 60.0):
        self.mean = 0.0
        self.var = 0.0
        self.std = 0.0
        self.samples = 0
        self.half_life = half_life_sec
        self.last_ts = 0.0

    def update(self, spread: float):
        now = time.time()
        if self.samples == 0:
            self.mean = spread
            self.var = 0.0
            self.last_ts = now
        else:
            dt = now - self.last_ts
            if dt <= 0: dt = 0.001 # Prevent zero division or weirdness

            # alpha = 1 - exp(-ln(2)*dt/half_life)
            alpha = 1.0 - math.exp(-0.6931 * dt / self.half_life)

            diff = spread - self.mean
            incr = alpha * diff
            self.mean += incr
            self.var = (1 - alpha) * self.var + alpha * (diff * diff) # Estimation
            self.last_ts = now

        self.std = self.var ** 0.5
        self.samples += 1

class MarketData:
    def __init__(self, on_tick_callback: Optional[Callable[[str], None]] = None):
        self.stocks: Dict[str, MarketSnapshot] = {}
        self.futures: Dict[str, MarketSnapshot] = {}
        self._lock = threading.Lock()
        self.on_tick_callback = on_tick_callback

    def update_stock(self, tick: Any):
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            s = self.stocks.get(code, MarketSnapshot(code))

            # tick price
            if hasattr(tick, "close"): s.price = float(tick.close)
            elif hasattr(tick, "price"): s.price = float(tick.price)

            # bid/ask (best1) parsing
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    # bid_price might be list or scalar
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: s.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): s.bid = float(bp)

                    if isinstance(ap, list) and ap: s.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): s.ask = float(ap)
                except: pass

            # volume if available
            try:
                if hasattr(tick, "volume"): s.volume = int(tick.volume)
                elif hasattr(tick, "total_volume"): s.volume = int(tick.total_volume)
            except: 
                pass

            s.ts = time.time()
            self.stocks[code] = s

        if self.on_tick_callback and code:
            self.on_tick_callback(code)

    def update_future(self, tick: Any):
        code = ""
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            f = self.futures.get(code, MarketSnapshot(code))

            # tick price
            if hasattr(tick, "close"): f.price = float(tick.close)
            elif hasattr(tick, "price"): f.price = float(tick.price)

            # bid/ask (best1) parsing
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: f.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): f.bid = float(bp)

                    if isinstance(ap, list) and ap: f.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): f.ask = float(ap)
                except: pass

            # volume if available
            try:
                if hasattr(tick, "volume"): f.volume = int(tick.volume)
                elif hasattr(tick, "total_volume"): f.volume = int(tick.total_volume)
            except:
                pass

            f.ts = time.time()
            self.futures[code] = f

        if self.on_tick_callback and code:
            self.on_tick_callback(code)

    def get_stock(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.stocks.get(code)
    def get_future(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.futures.get(code)

class StrategyEngine:
    def __init__(self, market_data: MarketData, check_holdings_cb: Optional[Callable[[str], bool]] = None):
        self.md = market_data
        self.check_holdings_cb = check_holdings_cb
        self.stats: Dict[Tuple[str, str], StrategyState] = {}

        # Parameters
        self.Z_ENTRY = 2.0
        self.Z_EXIT = 0.5
        self.MIN_STD = 0.1 # Floor to prevent division by zero or huge Z on flat markets

    def _get_stats(self, stock_code: str, future_code: str) -> StrategyState:
        key = (stock_code, future_code)
        if key not in self.stats:
            self.stats[key] = StrategyState(half_life_sec=300) # 5-min half life
        return self.stats[key]

    def on_tick(self, stock_code: str, future_code: str) -> Optional[TradeIntent]:
        stk = self.md.get_stock(stock_code)
        fut = self.md.get_future(future_code)

        # Helper for mid price
        def _get_px(s):
            if not s: return 0.0
            if s.bid > 0 and s.ask > 0: return (s.bid + s.ask) / 2
            return s.price

        stk_px = _get_px(stk)
        fut_px = _get_px(fut)

        if stk_px <= 0 or fut_px <= 0:
            return None

        # 1. Calculate Spread (Mid Price if available)
        stk_px = stk.price
        if stk.bid > 0 and stk.ask > 0:
            stk_px = (stk.bid + stk.ask) / 2

        fut_px = fut.price
        if fut.bid > 0 and fut.ask > 0:
            fut_px = (fut.bid + fut.ask) / 2

        spread = fut_px - stk_px

        # 2. Update Stats
        stats = self._get_stats(stock_code, future_code)
        stats.update(spread)

        if stats.samples < 10: # Warmup
            return None

        # 3. Calculate Z-Score
        std = max(stats.std, self.MIN_STD)
        z_score = (spread - stats.mean) / std

        msg = f"[Strategy] {stock_code} Spread={spread:.2f} Z={z_score:.2f} (µ={stats.mean:.2f} σ={std:.2f})"

        # Optimize Logging (Fix A3-v3: Smart Filtering)
        is_entry = z_score > self.Z_ENTRY
        is_close_signal = abs(z_score) < self.Z_EXIT

        has_position = False
        if self.check_holdings_cb:
            has_position = self.check_holdings_cb(stock_code)

        should_print_newline = False

        if is_entry:
             # Only print if we DON'T have it yet (Opportunity)
             if not has_position:
                 should_print_newline = True
        elif is_close_signal:
             # Only print if we DO have it (Action needed)
             if has_position:
                 should_print_newline = True

        if should_print_newline:
              print(msg) 
        pass

        # 4. Generate Signals
        # Entry: Future is Expensive (High Spread) -> Short Future / Long Stock
        if z_score > self.Z_ENTRY:
            return TradeIntent(
                type=SignalType.OPEN,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"Z={z_score:.2f} > {self.Z_ENTRY}"
            )

        # Exit: Spread normalizes (Low Z)
        elif abs(z_score) < self.Z_EXIT:
            return TradeIntent(
                type=SignalType.CLOSE,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"|Z|={abs(z_score):.2f} < {self.Z_EXIT}"
            )

        return None

# --- Execution Engine (The Gateway) ---

class ExecutionEngine:
    """
    Handles connection to Shioaji, Authentication, and Raw Order Placement.
    Does NOT manage state. Just executes commands.
    """
    def __init__(self):
        print(f"[Execution] CWD: {os.getcwd()}")
        load_dotenv()

        # Init API
        # Use Simulation=True by default unless overridden
        self.api = sj.Shioaji(simulation=True)

        # Load Credentials (va3 style)
        self.person_id = os.getenv("Sinopack_PERSON_ID") 
        self.password = os.getenv("Sinopack_PASSWORD")
        self.ca_api_key = os.getenv("Sinopack_CA_API_KEY")
        self.ca_secret_key = os.getenv("Sinopack_CA_SECRET_KEY")
        self.ca_path = os.getenv("Sinopack_CA_PATH")
        self.ca_password = os.getenv("Sinopack_CA_PASSWORD")

        # Debug
        k_len = len(self.ca_api_key) if self.ca_api_key else 0
        s_len = len(self.ca_secret_key) if self.ca_secret_key else 0
        print(f"[Execution] Keys loaded. API_KEY len={k_len}, SECRET_KEY len={s_len}, PERSON_ID={self.person_id}")

        self.stock_account = None
        self.futopt_account = None

        # Callback for TxManager to hook into
        self.on_order_callback = None 

        # Track recent orders for 'o' command
        self.recent_orders = []
        self.seqno_to_trade = {} # List[Dict] 

    def get_contract(self, code: str, security_type: str = "Stock"):
        if security_type == "Stock":
             return resolve_stock_contract(self.api, code)
        elif security_type == "Future":
             return resolve_future_contract(self.api, code)
        return None

    def login(self):
        print("[Execution] Connecting to Shioaji API...")
        if not self.ca_api_key or not self.ca_secret_key:
            print("[Execution] Fatal: Missing API Key/Secret.")
            return False

        try:
            # va3 login style
            self.api.login(
                api_key=self.ca_api_key, 
                secret_key=self.ca_secret_key,
                contracts_cb=lambda x: print(f"[Execution] Contracts loaded: {x}"),
                subscribe_trade=True
            )
            print("[Execution] Login success (Session Up). Waiting for contracts...")
            # Simple wait for contract load (va3 waits 5s)
            time.sleep(5.0)
        except Exception as e:
            print(f"[Execution] Login failed: {e}")
            return False

        print("[Execution] CA Activation SKIPPED (Simulation Mode Stability).")

        # Set Accounts
        self.stock_account = self.api.stock_account
        self.futopt_account = self.api.futopt_account

        if not self.stock_account or not self.futopt_account:
            print("[Execution] Warning: Accounts not retrieved (Sim mode maybe?).")
        else:
            print(f"[Execution] Stock Account: {self.stock_account.account_id}")
            print(f"[Execution] Future Account: {self.futopt_account.account_id}")

        # Hook global callbacks
        self.api.set_order_callback(self._wrap_callback)
        return True

    def _wrap_callback(self, *args, **kwargs):
        """
        Routes Shioaji callbacks (supports both (topic, msg) and (OrderState) signatures).
        """
        if not self.on_order_callback:
            return

        # Case A: (topic, msg)
        if len(args) == 2 and isinstance(args[0], str):
            topic, msg = args
            if topic != "OrderState":
                return
            data = msg or {}

        # Case B: (state,) or similar object
        elif len(args) >= 1:
            topic = "OrderState" # Default for direct object callbacks
            state = args[0]
            # Convert to dict
            if isinstance(state, dict):
                data = state
            elif hasattr(state, "to_dict"):
                data = state.to_dict()
            else:
                data = getattr(state, "__dict__", {}) or {}
        else:
            return

        op = data.get("operation", {}) or {}
        order = data.get("order", {}) or {}
        status = data.get("status", {}) or {}

        op_code = op.get("op_code", "")
        op_msg = op.get("op_msg", "")

        seqno = order.get("seqno", "") or order.get("id", "") or order.get("ordno", "")
        oid = order.get("id", "") or order.get("ordno", "")

        # Log all OrderState events to console to debug missing fills
        if topic == "OrderState":
             print(f"[CB] Seq={seqno} OID={oid} Op={op_code} Msg={op_msg} Stat={status.get('status')}")

        self.on_order_callback(oid, seqno, op_code, op_msg, status)

    def place_stock_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        """
        Returns Order ID (seqno) if successful, None otherwise.
        """
        try:
            contract = resolve_stock_contract(self.api, code)
            if not contract:
                print(f"[Execution] Stock contract not found: {code}")
                return None

            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.StockPriceType.LMT if price_type == "LMT" else sj_constant.StockPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC

            # Fix 2B: MKT price should be 0
            if pt == sj_constant.StockPriceType.MKT:
                price = 0.0

            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.stock_account
                )
            )

            # Track for cancellation
            self.seqno_to_trade[trade.order.seqno] = trade

            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Stock")

            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Stock Order Failed: {e}")
            return None

    def place_future_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        try:
            contract = resolve_future_contract(self.api, code)
            if not contract:
                print(f"[Execution] Future contract not found: {code}")
                return None

            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.FuturesPriceType.LMT if price_type == "LMT" else sj_constant.FuturesPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC

            # Fix 2B: MKT price should be 0
            if pt == sj_constant.FuturesPriceType.MKT:
                price = 0.0

            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.futopt_account
                )
            )

            self.seqno_to_trade[trade.order.seqno] = trade

            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Future")

            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Future Order Failed: {e}")
            return None

    def _track_order(self, seqno, code, action, price, qty, product):
        ts = time.strftime("%H:%M:%S")
        self.recent_orders.append({
            "time": ts,
            "seqno": seqno,
            "code": code,
            "action": action,
            "price": price,
            "qty": qty,
            "product": product,
            "status": "Submitted"
        })
        # Keep last 50
        if len(self.recent_orders) > 50:
            self.recent_orders.pop(0)

    def dump_orders(self) -> str:
        if not self.recent_orders:
             return "No orders yet."
        lines = ["\n=== RECENT ORDERS ==="]
        for o in self.recent_orders:
            lines.append(f"{o['time']} [{o['product']}] {o['action']} {o['code']} Q={o['qty']} P={o['price']} Seq={o['seqno']} St={o['status']}")
        return "\n".join(lines)

    def cancel_all_orders(self):
        """Cancel all pending orders in both accounts"""
        print("[Execution] Cancelling all open orders...")
        try:
            self.api.update_status()
            for trade in self.api.list_trades():
                if trade.status.status in ("PreSubmitted", "Submitted", "PartFilled"):
                    self.api.cancel_order(trade)
                    print(f"  Cancelled: {trade.contract.code} {trade.order.action}")
        except Exception as e:
            print(f"[Execution] Cancel failed: {e}")

    def cancel_order_by_seqno(self, seqno: str):
        """Cancel order using stored trade object."""
        try:
            trade = self.seqno_to_trade.get(seqno)
            if trade:
                self.api.cancel_order(trade)
                print(f"[Execution] Cancelled order {seqno}")
            else:
                print(f"[Execution] Cannot cancel {seqno}: Trade object not found.")
        except Exception as e:
            print(f"[Execution] Cancel failed for {seqno}: {e}")

    def get_order_status(self, seqno: str) -> Optional[Dict]:
        """Fetch latest status for a specific order by seqno via polling."""
        try:
            # Refresh both accounts to be sure
            if self.stock_account: self.api.update_status(self.stock_account)
            if self.futopt_account: self.api.update_status(self.futopt_account)

            trades = self.api.list_trades()

            for trade in trades:
                if trade.order.seqno == seqno:
                    status_str = trade.status.status # e.g. "Filled", "Cancelled"
                    deal_quantity = trade.status.deal_quantity
                    return {
                        "status": status_str,
                        "deal_quantity": deal_quantity,
                        "ordno": trade.order.ordno,
                        "id": trade.order.id
                    }
        except Exception:
            pass
        return None

    def get_all_positions(self) -> Dict[str, int]:
        """Returns map of code -> net signed quantity"""
        pos_map = {}
        try:
             # Stocks
             if self.stock_account:
                 for p in self.api.list_positions(self.stock_account):
                     pos_map[p.code] = int(p.quantity)
             # Futures
             if self.futopt_account:
                 for p in self.api.list_positions(self.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj_constant.Action.Buy else -qty
                     pos_map[p.code] = net
        except Exception:
            pass
        return pos_map

    def dump_positions(self) -> str:
        lines = ["\n=== POSITIONS ==="]
        try:
             # Force update
             if self.stock_account: self.api.update_status(self.stock_account)
             if self.futopt_account: self.api.update_status(self.futopt_account)

             # Stock
             if self.stock_account:
                 pos = self.api.list_positions(self.stock_account)
                 lines.append(f"Stocks ({len(pos)}):")
                 for p in pos:
                     lines.append(f"  {p.code} Qty={int(p.quantity)} avgP={p.price}")

             # Future
             if self.futopt_account:
                 pos = self.api.list_positions(self.futopt_account)
                 lines.append(f"Futures ({len(pos)}):")
                 for p in pos:
                     code = getattr(p, "code", "Unknown")
                     qty = getattr(p, "quantity", 0)
                     price = getattr(p, "price", 0)
                     lines.append(f"  {code} Qty={int(qty)} avgP={price}")

        except Exception as e:
             lines.append(f"Error: {e}")
        return "\n".join(lines)

# --- Core Transaction Classes ---

class BaseTransaction:
    def __init__(self, intent: TradeIntent, tx_mgr):
        self.tx_id = str(uuid.uuid4())[:8]
        self.intent = intent
        self.mgr = tx_mgr
        self.state = TransactionState.INIT
        self.created_at = time.time()
        self.updated_at = time.time()
        self.state_enter_ts = time.time()

        self.stock_order = OrderStub()
        self.future_order = OrderStub()

        self.last_poll_ts = 0

        self.log(f"Transaction Created: {intent}")

    def log(self, msg: str):
        ts = time.strftime("%H:%M:%S")
        print(f"[{ts}] [Tx-{self.tx_id}] {msg}")

    def set_state(self, new_state: TransactionState, msg: str = ""):
        self.state = new_state
        self.state_enter_ts = time.time()
        if msg:
            self.log(msg)

    def update(self):
        self.updated_at = time.time()
        if self.state == TransactionState.INIT:
            self._step_init()
        elif self.state == TransactionState.LEG1_SUBMITTED:
            self._check_leg1_polling() # Polling Failsafe
            self._check_leg1_timeout()
        elif self.state == TransactionState.LEG1_FILLED:
            self._step_place_leg2()
        elif self.state == TransactionState.LEG2_SUBMITTED:
            self._check_leg2_polling() # Polling Failsafe
            self._check_leg2_timeout()

    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        # Match order by seqno
        # Leg 1
        if seqno == self.stock_order.seqno:
            self.log(f"Leg 1 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                # Check fill
                delta = _apply_fill(self.stock_order, status_data)
                if delta > 0:
                    self.log(f"Leg 1 Partial Fill: +{delta} (Total: {self.stock_order.filled_qty})")
                    if self.stock_order.filled_qty >= self.intent.qty:
                        self.set_state(TransactionState.LEG1_FILLED, "Leg 1 Fully Filled.")
                        self.stock_order.status = "Filled"
            else:
                 self.stock_order.status = "Failed"
                 self.stock_order.error_msg = msg
                 self.set_state(TransactionState.FAILED, f"Leg 1 FAILED: {msg}")

        # Leg 2
        elif seqno == self.future_order.seqno:
            self.log(f"Leg 2 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                delta = _apply_fill(self.future_order, status_data)
                if delta > 0:
                    self.log(f"Leg 2 Partial Fill: +{delta} (Total: {self.future_order.filled_qty})")
                    if self.future_order.filled_qty >= self.intent.qty:
                        self.set_state(TransactionState.COMPLETED, "Transaction COMPLETED.")
                        self.future_order.status = "Filled"
            else:
                 self.future_order.status = "Failed"
                 self.future_order.error_msg = msg
                 self.set_state(TransactionState.FAILED, f"Leg 2 FAILED: {msg}")

    # --- Step Implementations ---

    def _step_init(self):
        snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
        if not snapshot:
            self.log("No market data for Leg 1. Waiting...")
            return 

        if snapshot.price <= 0:
            return 

        limit_price = snapshot.price * 1.01

        self.log(f"Placing Leg 1 (Stock {self.intent.stock_code}) Market Order...")

        action = "Buy" if self.intent.type == SignalType.OPEN else "Sell"

        seqno = self.mgr.execution.place_stock_order(
            self.intent.stock_code, action, 0, self.intent.qty, "MKT", "ROD"
        )

        if seqno:
            self.stock_order.seqno = seqno
            self.stock_order.status = "Submitted"
            self.state = TransactionState.LEG1_SUBMITTED
            self.log(f"Leg 1 Submitted SeqNo: {seqno}")
            self.log(f"Leg 1 Submitted SeqNo: {seqno}")
        else:
            self.set_state(TransactionState.FAILED, "Leg 1 Submission Failed")

    def _check_leg1_timeout(self):
        if time.time() - self.state_enter_ts > 90:
            self.log("Leg 1 Timeout. Cancelling...")
            self.mgr.execution.cancel_order_by_seqno(self.stock_order.seqno)
            self.set_state(TransactionState.FAILED, "Leg 1 Timeout & Cancelled")

    def _step_place_leg2(self):
        filled_qty = self.stock_order.filled_qty
        if filled_qty <= 0:
            self.log("Leg 1 Filled Qty is 0? Strange.")
            self.state = TransactionState.FAILED
            return

        hedge_qty = filled_qty 

        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Qty={hedge_qty}...")
        action = "Sell" if self.intent.type == SignalType.OPEN else "Buy"

        snapshot = self.mgr.market_data.get_future(self.intent.future_code)
        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Market Order...")

        seqno = self.mgr.execution.place_future_order(
            self.intent.future_code, action, 0, hedge_qty, "MKT", "IOC"
        )

        if seqno:
            self.future_order.seqno = seqno
            self.future_order.status = "Submitted"
            self.set_state(TransactionState.LEG2_SUBMITTED)
            self.log(f"Leg 2 Submitted SeqNo: {seqno}")
        else:
            self.set_state(TransactionState.FAILED, "Leg 2 Submission Failed")

    def _check_leg2_timeout(self):
        if time.time() - self.state_enter_ts > 20:
            self.log("Leg 2 Timeout. Cancelling...")
            self.mgr.execution.cancel_order_by_seqno(self.future_order.seqno)
            self.set_state(TransactionState.FAILED, "Leg 2 Timeout & Cancelled")

    # --- Polling Failsafe ---
    def _check_leg1_polling(self):
        if time.time() - self.last_poll_ts < 2.0: return
        self.last_poll_ts = time.time()

        status = self.mgr.execution.get_order_status(self.stock_order.seqno)
        if status:
            s_str = status.get("status")
            qty = status.get("deal_quantity", 0)

            if s_str == "Filled" or qty >= self.intent.qty:
                self.log(f"[Polling] Detected Leg 1 Fill! Qty={qty}")
                self.on_order_update(self.stock_order.seqno, "00", "Polled Fill", status)
            elif s_str == "Cancelled":
                self.log(f"[Polling] Detected Leg 1 Cancel.")
                self.set_state(TransactionState.FAILED, "Leg 1 Cancelled")
        else:
             pass

    def _check_leg2_polling(self):
        if time.time() - self.last_poll_ts < 2.0: return
        self.last_poll_ts = time.time()

        status = self.mgr.execution.get_order_status(self.future_order.seqno)
        if status:
            s_str = status.get("status")
            qty = status.get("deal_quantity", 0)
            if s_str == "Filled" or qty >= self.intent.qty:
                self.log(f"[Polling] Detected Leg 2 Fill! Qty={qty}")
                self.on_order_update(self.future_order.seqno, "00", "Polled Fill", status)
            elif s_str == "Cancelled":
                self.log(f"[Polling] Detected Leg 2 Cancel.")
                self.set_state(TransactionState.FAILED, "Leg 2 Cancelled")

class OpenArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Open:
    1. Buy Stock
    2. Sell Future
    """
    pass

class CloseArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Exit:
    1. Buy Future (Close Short) - Priority to remove unlimited risk
    2. Sell Stock (Close Long)
    """
    def update(self):
        # 1. INIT -> Buy Future
        if self.state == TransactionState.INIT:
            snapshot = self.mgr.market_data.get_future(self.intent.future_code)
            if not snapshot or snapshot.price <= 0:
                 self.log("No Future Price. Waiting...")
                 return

            self.log(f"Closing: Buying Future {self.intent.future_code} Market Order...")

            seqno = self.mgr.execution.place_future_order(
                self.intent.future_code, "Buy", 0, self.intent.qty, "MKT", "IOC" 
            )

            if seqno:
                self.future_order.seqno = seqno
                self.future_order.status = "Submitted"
                self.set_state(TransactionState.LEG1_SUBMITTED)
            else:
                 self.set_state(TransactionState.FAILED, "Future Buy Failed")

        elif self.state == TransactionState.LEG1_SUBMITTED:
             if time.time() - self.state_enter_ts > 10:
                  self.log("Close Leg 1 (Future) Timeout. Cancelling...")
                  self.set_state(TransactionState.FAILED)

        elif self.state == TransactionState.LEG1_FILLED:
            filled_qty = self.future_order.filled_qty
            hedge_qty = filled_qty

            self.log(f"Closing: Selling Stock {self.intent.stock_code} Qty={hedge_qty}...")
            snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
            self.log(f"Closing: Selling Stock {self.intent.stock_code} Market Order...")

            seqno = self.mgr.execution.place_stock_order(
                self.intent.stock_code, "Sell", 0, hedge_qty, "MKT", "ROD"
            )

            if seqno:
                self.stock_order.seqno = seqno
                self.set_state(TransactionState.LEG2_SUBMITTED)
            else:
                self.set_state(TransactionState.FAILED, "Stock Sell Failed")

        elif self.state == TransactionState.LEG2_FILLED:
            self.set_state(TransactionState.COMPLETED, "Arbitrage Close Complete")

    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        if seqno == self.future_order.seqno:
            self.log(f"[Close] Future Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Future leg failed: {msg}")
                return

            delta = _apply_fill(self.future_order, status_data)
            if delta > 0:
                self.log(f"[Close] Future fill +{delta} (total {self.future_order.filled_qty})")

            if self.future_order.filled_qty >= self.intent.qty:
                self.set_state(TransactionState.LEG1_FILLED, "Future leg filled")

        elif seqno == self.stock_order.seqno:
            self.log(f"[Close] Stock Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Stock leg failed: {msg}")
                return

            delta = _apply_fill(self.stock_order, status_data)
            if delta > 0:
                self.log(f"[Close] Stock fill +{delta} (total {self.stock_order.filled_qty})")

            tgt = self.future_order.filled_qty
            if self.stock_order.filled_qty >= tgt and tgt > 0:
                self.set_state(TransactionState.LEG2_FILLED, "Stock leg filled (Hedge Complete).")

# --- Pair Discovery ---

class PairDiscovery:
    def __init__(self, api: sj.Shioaji):
        self.api = api

    def _load_local_history(self) -> Tuple[set, set]:
        l_stocks = set()
        l_futures = set()
        path = "order_history.jsonl"
        if not os.path.exists(path):
            return l_stocks, l_futures

        print(f"[Discovery] Reading local history from {path}...")
        try:
            with open(path, "r", encoding="utf-8") as f:
                lines = f.readlines()
                for line in reversed(lines):
                    try:
                        rec = json.loads(line)
                        f_code = rec.get("fut_code")
                        s_code = rec.get("stock_code")
                        if f_code: l_futures.add(f_code)
                        if s_code: l_stocks.add(s_code)
                    except Exception:
                        pass
            print(f"[Discovery] Recovered from history - Stocks: {len(l_stocks)}, Futures: {len(l_futures)}")
            if l_futures: print(f"[Discovery] History Futures Sample: {list(l_futures)[:5]}")
        except Exception as e:
            print(f"[Discovery] History load failed: {e}")

        return l_stocks, l_futures

    def scan(self, limit: int = 5) -> List[Tuple[str, str]]:
        found = [] 
        held_stocks = set()
        held_futures = set()

        print("[Discovery] Syncing positions (wait 3s)...")
        for attempt in range(3):
            try:
                if hasattr(self.api, "update_status"):
                    try: self.api.update_status(self.api.stock_account)
                    except Exception: pass
                    try: self.api.update_status(self.api.futopt_account) 
                    except Exception: pass
                time.sleep(3.0) 
                break
            except Exception as e:
                print(f"[Discovery] Sync attempt {attempt+1} failed: {e}")
                time.sleep(2.0)

        h_stocks, h_futures = self._load_local_history()

        print("[Discovery] Scanning positions first...")

        for attempt in range(3):
            try:
                held_stocks.clear()
                held_futures.clear()

                if self.api.stock_account:
                    pos = self.api.list_positions(self.api.stock_account)
                    for p in pos:
                        code = getattr(p, "code", "")
                        if code: held_stocks.add(code)

                if self.api.futopt_account:
                    pos = self.api.list_positions(self.api.futopt_account)
                    for p in pos:
                        code = getattr(p, "code", "")
                        if code: held_futures.add(code)

                break
            except Exception as e:
                print(f"[Discovery] API Position scan attempt {attempt+1} failed: {e}")
                time.sleep(2.0)
                if attempt == 2:
                    print("[Discovery] Giving up on Position Scan. Assuming 0 positions.")

        print(f"[Discovery] Active Held Stocks: {held_stocks}")
        print(f"[Discovery] Active Held Futures: {held_futures}")

        # 2) Build mapping: stock underlying_code -> future contract
        print("[Discovery] Scanning contracts for candidates...")
        candidates_map = {} # stock_code -> future_contract

        try:
            for contract in iter_future_contracts(self.api):
                if not contract:
                    continue
                f_code = getattr(contract, "code", "")
                u_code = getattr(contract, "underlying_code", "") 
                if not f_code or not u_code:
                    continue
                if u_code not in candidates_map:
                    candidates_map[u_code] = contract
        except Exception as e:
            print(f"[Discovery] Contract map failed: {e}")

        # B) Add Held Pairs
        for s_code in held_stocks:
            if s_code in candidates_map:
                f_c = candidates_map[s_code]
                pair = (s_code, f_c.code)
                if pair not in found:
                    found.append(pair)

        remaining = limit - len(found)
        if remaining > 0:
            print(f"[Discovery] Need {remaining} more pairs. Fetching volumes for {len(candidates_map)} candidates...")

            stk_contracts = []
            valid_u_codes = []
            none_count = 0

            for u_code in candidates_map.keys():
                try:
                    c = resolve_stock_contract(self.api, u_code)
                    if c is None:
                        none_count += 1
                        continue
                    stk_contracts.append(c)
                    valid_u_codes.append(u_code)
                except Exception:
                    pass

            if none_count > 0:
                print(f"[Discovery] Filtered out {none_count} None/Invalid contracts to prevent crash.")

            vol_map = {} 

            blue_chips = {
                '2330': 100000, '2317': 90000, '2454': 85000, '2303': 80000, '2881': 75000,
                '1301': 70000, '1303': 69000, '2882': 68000, '2002': 67000, '1216': 66000,
                '2412': 65000, '2308': 64000, '2891': 63000, '3231': 62000, '2382': 61000,
                '2886': 60000, '2884': 59000, '2357': 58000, '1101': 57000, '2892': 56000,
                '5880': 55000, '2880': 54000, '3008': 53000, '2603': 52000, '3711': 51000,
                '2885': 50000, '2207': 49000, '3045': 48000, '5876': 47000, '2301': 46000
            }

            for bc_code, bc_vol in blue_chips.items():
                if bc_code in candidates_map:
                     vol_map[bc_code] = bc_vol

            chunk_size = 200
            for i in range(0, len(stk_contracts), chunk_size):
                chunk = stk_contracts[i:i+chunk_size]
                try:
                    snaps = self.api.snapshots(chunk)
                    for s in snaps:
                        price = float(getattr(s, 'close', 0) or getattr(s, 'reference_price', 0) or 0)
                        if price > 500:
                            vol_map[s.code] = 0
                            continue

                        v = int(getattr(s, 'total_volume', 0) or 0)
                        if v == 0 and s.code in blue_chips:
                             v = blue_chips[s.code]
                        vol_map[s.code] = v
                except Exception as e:
                    print(f"[Discovery] Snapshot chunk failed: {e}")

            # Sort by Stock Volume Desc
            sorted_candidates = sorted(valid_u_codes, key=lambda x: vol_map.get(x, 0), reverse=True)
            
            # --- Future Volume Filter (New) ---
            # Take top 50 candidates and verify their Futures have liquidity
            top_check = sorted_candidates[:50]
            fut_vol_map = {}
            if top_check:
                print(f"[Discovery] Verifying Future Liquidity for top {len(top_check)} candidates...")
                futures_to_snap = []
                for u_code in top_check:
                    f_c = candidates_map.get(u_code)
                    if f_c: futures_to_snap.append(f_c)
                
                # Snapshot Futures
                try:
                    # chunk it just in case
                    for i in range(0, len(futures_to_snap), 100):
                        chunk = futures_to_snap[i:i+100]
                        for s in self.api.snapshots(chunk):
                            # Future Snapshot: volume or total_volume
                            fv = int(getattr(s, 'total_volume', 0) or getattr(s, 'volume', 0) or 0)
                            # Also check price > 0 to be safe
                            fp = float(getattr(s, 'price', 0) or getattr(s, 'close', 0) or 0)
                            
                            fc = getattr(s, 'code', '')
                            if fv > 0 and fp > 0:
                                fut_vol_map[fc] = fv
                except Exception as e:
                    print(f"[Discovery] Future snapshot failed: {e}")

            # Pick Top N (with valid Future Volume)
            filtered_candidates = []
            for u in sorted_candidates:
                f_c = candidates_map.get(u)
                if not f_c: continue
                # Pass if in held_stocks (Priority 1 is safe) OR if Future Volume > 0
                # Wait, held stocks are already in 'found'. 'sorted_candidates' are for NEW pairs.
                # So strict check: Future Volume MUST be > 0.
                if fut_vol_map.get(f_c.code, 0) > 0:
                    filtered_candidates.append(u)
            
            print(f"[Discovery] Candidates after Fut Vol Filter: {len(filtered_candidates)} (from {len(sorted_candidates)})")
            
            for u_code in filtered_candidates:
                if len(found) >= limit: break
                is_added = any(p[0] == u_code for p in found)
                if is_added: continue
                f_c = candidates_map[u_code]
                found.append((u_code, f_c.code))
                print(f"[Discovery] Added Top Vol Pair: {u_code} (Vol={vol_map.get(u_code,0)})")

            if not found:
                if resolve_stock_contract(self.api, "2330"):
                    for contract in iter_future_contracts(self.api):
                        if getattr(contract, "underlying_code", "") == "2330":
                            found.append(("2330", getattr(contract, "code", "")))
                            break

            
            final_list = found[:limit]
            print(f"[Discovery] Final Pairs: {final_list}")
            return final_list




# --- Transaction Manager ---

class TransactionManager:
    def __init__(self):
        self._lock = threading.Lock()
        self.market_data = MarketData(on_tick_callback=self._on_market_tick)
        self.execution = ExecutionEngine()
        self.held_positions: set[str] = set()

        def _check_holdings(stock_code):
            return (stock_code in self.active_transactions) or (stock_code in self.held_positions)

        self.strategy = StrategyEngine(self.market_data, check_holdings_cb=_check_holdings)

        self.active_transactions: Dict[str, BaseTransaction] = {}
        self.completed_transactions: List[BaseTransaction] = []
        self.cooldowns: Dict[str, float] = {}

        self.monitored_pairs: List[Tuple[str, str]] = []
        self._pair_map: Dict[str, List[Tuple[str, str]]] = {}

        self.execution.on_order_callback = self.on_execution_event

        self.running = False
        self.last_sync_ts = 0

    def start(self):
        if not self.execution.login():
            return False

        self.running = True

        @self.execution.api.on_bidask_stk_v1(bind=True)
        def _on_stk_callback(self_api, exchange, bidask):
            self.market_data.update_stock(bidask)

        @self.execution.api.on_bidask_fop_v1(bind=True)
        def _on_fop_callback(self_api, exchange, bidask):
            self.market_data.update_future(bidask)

        self._sync_held_positions()

        @self.execution.api.on_tick_stk_v1(bind=True)
        def _on_tick_stk_callback(self_api, exchange, tick):
            self.market_data.update_stock(tick)

        @self.execution.api.on_tick_fop_v1(bind=True)
        def _on_tick_fop_callback(self_api, exchange, tick):
            self.market_data.update_future(tick)

        return True

    def stop(self):
        self.running = False

    def discover_and_subscribe(self):
        discovery = PairDiscovery(self.execution.api)
        self.monitored_pairs = discovery.scan(limit=20)
        self._build_pair_map()

    def _sync_held_positions_fast(self):
        try:
            pos_map = self.execution.get_all_positions()
            current_held = set()
            for code, qty in pos_map.items():
                if qty != 0:
                    current_held.add(code)

            recalc_held = current_held.copy()
            with self._lock:
                for tx in self.active_transactions.values():
                    recalc_held.add(tx.intent.stock_code)

            self.held_positions = recalc_held
        except Exception: 
            pass

    def _sync_held_positions(self):
        print("[TxMgr] Syncing initial positions (Wait 2s for API)...")
        time.sleep(2.0)
        try:
            if self.execution.stock_account: 
                self.execution.api.update_status(self.execution.stock_account)
                print("[TxMgr] Stock Account Status Updated.")
            if self.execution.futopt_account:
                self.execution.api.update_status(self.execution.futopt_account)
                print("[TxMgr] Future Account Status Updated.")

            pos_map = self.execution.get_all_positions()
            print(f"[TxMgr] Raw Positions Attempt 1: {pos_map}")

            if not pos_map:
                 print("[TxMgr] Retrying sync in 2s...")
                 time.sleep(2.0)
                 if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
                 pos_map = self.execution.get_all_positions()
                 print(f"[TxMgr] Raw Positions Attempt 2: {pos_map}")

            count = 0
            for code, qty in pos_map.items():
                if qty != 0:
                    self.held_positions.add(code)
                    count += 1
            print(f"[TxMgr] Initial Sync: {count} active positions cached: {self.held_positions}")
        except Exception as e:
            print(f"[TxMgr] Initial Sync Failed: {e}")

    def _build_pair_map(self):
        self._pair_map.clear()
        for s, f in self.monitored_pairs:
            if s not in self._pair_map: self._pair_map[s] = []
            self._pair_map[s].append((s, f))

            if f not in self._pair_map: self._pair_map[f] = []
            self._pair_map[f].append((s, f))

        print(f"[TxMgr] Indexed {len(self.monitored_pairs)} pairs into {len(self._pair_map)} unique codes.")

        print(f"[TxMgr] Subscribing to {len(self.monitored_pairs)} pairs...")
        for s, f in self.monitored_pairs:
            print(f"[TxMgr] Subscribed: {s} <-> {f}")
            c_stk = resolve_stock_contract(self.execution.api, s)
            c_fut = resolve_future_contract(self.execution.api, f)

            if not c_stk:
                print(f"[SUBSCRIBE][ERR] Stock contract NOT FOUND: {s}")
            if not c_fut:
                print(f"[SUBSCRIBE][ERR] Future contract NOT FOUND: {f}")

            if c_stk:
                self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.Tick)
                self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.BidAsk)
            if c_fut:
                self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.Tick)
                self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.BidAsk)

    def _on_market_tick(self, code: str):
        affected_pairs = self._pair_map.get(code)
        if not affected_pairs:
            return

        for s, f in affected_pairs:
            with self._lock:
                if s in self.active_transactions:
                    continue

            intent = self.strategy.on_tick(s, f)
            if intent:
                self.request_new_transaction(intent)

    def _check_position_safety(self, intent: TradeIntent) -> bool:
        positions = self.execution.get_all_positions()

        s_qty = positions.get(intent.stock_code, 0)
        f_qty = positions.get(intent.future_code, 0)

        if intent.type == SignalType.OPEN:
             if abs(s_qty) > 0 or abs(f_qty) > 0:
                  print(f"[TxMgr] REJECT OPEN: Existing Position found {intent.stock_code}={s_qty}, {intent.future_code}={f_qty}")
                  return False

        elif intent.type == SignalType.CLOSE:
             if not (s_qty > 0 and f_qty < 0):
                  print(f"[TxMgr] REJECT CLOSE: Position not arbitrage-shape (s={s_qty}, f={f_qty}). Use Repair instead.")
                  self.cooldowns[intent.stock_code] = time.time() + 60
                  self.cooldowns[intent.future_code] = time.time() + 60
                  return False

             if s_qty == 0 and f_qty == 0:
                  return False

        return True

    def request_new_transaction(self, intent: TradeIntent) -> bool:
        with self._lock:
            if intent.stock_code in self.active_transactions:
                return False

            for k in (intent.stock_code, intent.future_code):
                 if k in self.cooldowns and time.time() < self.cooldowns[k]:
                     return False

            if not self._check_position_safety(intent):
                 return False

            print(f"[TxMgr] ACCEPT: Starting new transaction for {intent.stock_code} ({intent.details})")

            if intent.type == SignalType.OPEN:
                tx = OpenArbitrageTransaction(intent, self)
            elif intent.type == SignalType.CLOSE:
                tx = CloseArbitrageTransaction(intent, self)
            else:
                tx = BaseTransaction(intent, self) 

            self.active_transactions[intent.stock_code] = tx
            return True

    def run_step(self):
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except Exception:
            pass

        if time.time() - self.last_sync_ts > 30:
            self.last_sync_ts = time.time()
            self._sync_held_positions_fast()

        print(f"[Main] Active: {len(self.active_transactions)} | Monitored: {len(self.monitored_pairs)} | {time.strftime('%H:%M:%S')}", end='\r')

        with self._lock:
            codes = list(self.active_transactions.keys())

        clean_up_list = []

        for code in codes:
            with self._lock:
                tx = self.active_transactions.get(code)
            if not tx: 
                continue

            tx.update()

            if tx.state in [TransactionState.COMPLETED, TransactionState.FAILED, TransactionState.CANCELLED]:
                print(f"[TxMgr] Archiving Tx {tx.tx_id}")
                self.completed_transactions.append(tx)

                if tx.state == TransactionState.FAILED:
                     print(f"[TxMgr] Apply Cooldown (60s) for {code}")
                     with self._lock:
                        self.cooldowns[code] = time.time() + 60

                clean_up_list.append(code)

        if clean_up_list:
            with self._lock:
                for code in clean_up_list:
                    if code in self.active_transactions:
                        del self.active_transactions[code]

    def repair_positions(self):
        print("\n[TxMgr] === REPAIRING POSITIONS (Aggressive) ===")
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except Exception:
            pass

        stk_map = {}
        if self.execution.stock_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.stock_account):
                     stk_map[p.code] = int(p.quantity)
             except Exception:
                 pass

        fut_map = {} 
        if self.execution.futopt_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj.constant.Action.Buy else -qty
                     fut_map[p.code] = net
             except Exception:
                 pass

        for s, f in self.monitored_pairs:
             s_qty = stk_map.get(s, 0)
             f_net = fut_map.get(f, 0)

             if f_net > 0:
                  print(f"[Repair] {f} is Net Long ({f_net}). Closing (Sell)...")
                  self.execution.place_future_order(f, "Sell", 0, abs(f_net), "MKT", "IOC")

             elif f_net < 0:
                  if s_qty == 0:
                       print(f"[Repair] {f} is Naked Short ({f_net}). Closing (Buy)...")
                       self.execution.place_future_order(f, "Buy", 0, abs(f_net), "MKT", "IOC")

             if s_qty > 0 and f_net == 0:
                  print(f"[Repair] {s} is Naked Stock ({s_qty}). Closing (Sell)...")
                  self.execution.place_stock_order(s, "Sell", 0, s_qty, "MKT", "ROD")

        print("[Repair] Scan complete.\n")

    def repair_flatten_unpaired_futures(self, dry_run: bool = True, cooldown_sec: int = 30):
        print(f"\n[TxMgr] Fixing Unpaired Futures... (dry_run={dry_run})")

        try:
            if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
            if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
            time.sleep(1.0)
        except Exception:
            pass

        s_holdings = {}
        if self.execution.stock_account:
            try:
                for p in self.execution.api.list_positions(self.execution.stock_account):
                    s_holdings[p.code] = int(p.quantity)
            except Exception:
                pass

        f_holdings = {}
        if self.execution.futopt_account:
            try:
                for p in self.execution.api.list_positions(self.execution.futopt_account):
                    qty = int(p.quantity)
                    net = qty if p.direction == sj.constant.Action.Buy else -qty
                    f_holdings[p.code] = net
            except Exception:
                pass

        for s, f in self.monitored_pairs:
            if s_holdings.get(s, 0) != 0:
                self.held_positions.add(s)
            elif s in self.held_positions:
                self.held_positions.remove(s)

            s_qty = s_holdings.get(s, 0)
            f_qty = f_holdings.get(f, 0)

            if s_qty != 0 or f_qty == 0:
                continue

            exp = self.cooldowns.get(s, 0)
            if time.time() < exp:
                continue

            action = "Sell" if f_qty > 0 else "Buy"
            closing_qty = abs(f_qty)

            print(f"[Repair] {s}/{f}: Stock=0, Fut={f_qty} -> {action} {closing_qty} (flatten)")

            self.cooldowns[s] = time.time() + cooldown_sec

            if dry_run:
                continue

            self.execution.place_future_order(f, action, 0, closing_qty, "MKT", "IOC")

        print("[Repair] Done.\n")

    def on_execution_event(self, oid, seqno, op_code, op_msg, status_data):
        if op_code == "00":
             deal_qty = int(status_data.get("deal_quantity", 0))
             if deal_qty > 0:
                 pass

        found_active = False

        with self._lock:
            active_txs = list(self.active_transactions.values())

        for tx in active_txs:
            if (tx.stock_order.seqno and tx.stock_order.seqno == seqno):
                 if status_data.get("deal_quantity", 0):
                     self.held_positions.add(tx.intent.stock_code)

                 tx.on_order_update(seqno, op_code, msg=op_msg, status_data=status_data)
                 found_active = True
                 break
            elif (tx.future_order.seqno and tx.future_order.seqno == seqno):
                 tx.on_order_update(seqno, op_code, msg=op_msg, status_data=status_data)
                 found_active = True
                 break

        if found_active:
            return

        deal_qty = int(status_data.get("deal_quantity", 0))
        if deal_qty > 0:
             for tx in self.completed_transactions:
                 if (tx.stock_order.seqno and tx.stock_order.seqno == seqno) or \
                    (tx.future_order.seqno and tx.future_order.seqno == seqno):
                      print(f"\n[TxMgr] ⚠️ CRITICAL: Late Fill detected for Archived Tx {tx.tx_id} (Seq={seqno})!")
                      print(f"[TxMgr] This causes a Naked Position. Triggering Auto-Repair...")
                      self.repair_positions()
                      break

    def dump_status(self) -> str:
        lines = ["\n=== STATUS ==="]
        lines.append(f"Monitored Pairs: {len(self.monitored_pairs)}")
        for s, f in self.monitored_pairs:
            stk_data = self.market_data.get_stock(s)
            fut_data = self.market_data.get_future(f)
            s_price = stk_data.price if stk_data else 0.0
            f_price = fut_data.price if fut_data else 0.0

            stat = self.strategy.stats.get((s, f))
            extra = "(No Stats)"
            if stat and stat.samples > 0:
                 spread = f_price - s_price
                 min_std = getattr(self.strategy, 'MIN_STD', 1.0)
                 std = max(stat.std, min_std)
                 z = (spread - stat.mean) / std
                 extra = f"Sprd={spread:.1f} Z={z:.2f} (Avg={stat.mean:.1f})"

            lines.append(f"  {s}({s_price}) <-> {f}({f_price}) | {extra}")

        lines.append(f"\nActive Transactions: {len(self.active_transactions)}")
        for code, tx in self.active_transactions.items():
            lines.append(f"  [{code}] State={tx.state.name} Created={time.strftime('%H:%M:%S', time.localtime(tx.created_at))}")
            lines.append(f"    Leg1: {tx.stock_order.status} ({tx.stock_order.filled_qty}/{tx.intent.qty})")
            lines.append(f"    Leg2: {tx.future_order.status} ({tx.future_order.filled_qty})")

        lines.append(self.execution.dump_positions())

        return "\n".join(lines)

# --- Interactive Keyboard ---
try:
    import termios, tty, select
    _HAS_TERMIOS = True
except Exception:
    _HAS_TERMIOS = False

try:
    import msvcrt
    _HAS_MS = True
except Exception:
    _HAS_MS = False

class KeyboardMonitor(threading.Thread):
    """
    p -> print positions / transactions
    o -> print orders
    h -> help
    q -> quit
    x -> repair (close naked positions)
    """
    def __init__(self, manager: 'TransactionManager', poll_sec: float = 0.5):
        super().__init__(daemon=True)
        self.mgr = manager
        self.poll_sec = poll_sec
        self._stop_evt = threading.Event()

    def stop(self):
        self._stop_evt.set()

    def run(self):
        self._print_help_once()
        if _HAS_MS:
            self._run_windows()
        elif _HAS_TERMIOS:
            self._run_posix()
        else:
             print("[Keyboard] No interactive support (no termios/msvcrt).")
             while not self._stop_evt.is_set():
                 time.sleep(1.0)

    def _print_help_once(self):
        print("\n[Keyboard] p=status, o=orders, h=help, q=quit\n", flush=True)

    def _handle_key(self, ch: str):
        ch = (ch or "").strip()
        if not ch: return

        if ch.lower() == "p":
            print(self.mgr.dump_status(), flush=True)
        elif ch.lower() == "o":
            print(self.mgr.execution.dump_orders(), flush=True) 
        elif ch == "x":
            print("[Keyboard] 'x' pressed: Running repair (Dry Run requested but Logic is aggressive)...")
            self.mgr.repair_positions() 
        elif ch == "X":
            print("[Keyboard] 'X' pressed: FORCE REPAIR started...")
            self.mgr.repair_positions()
        elif ch == "h":
            self._print_help_once()
        elif ch == "q":
            print("\n[Keyboard] Quit requested...", flush=True)
            self.mgr.stop()
            self.stop()
            print("[Keyboard] Cancelling ALL open orders...", flush=True)
            self.mgr.execution.cancel_all_orders()

    def _run_windows(self):
        while not self._stop_evt.is_set():
            if msvcrt.kbhit():
                ch = msvcrt.getwch()
                self._handle_key(ch)
            time.sleep(self.poll_sec)

    def _run_posix(self):
        fd = sys.stdin.fileno()
        try:
            old = termios.tcgetattr(fd)
        except Exception:
            return

        try:
            tty.setcbreak(fd)
            while not self._stop_evt.is_set():
                r, _, _ = select.select([sys.stdin], [], [], self.poll_sec)
                if r:
                    ch = sys.stdin.read(1)
                    self._handle_key(ch)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

# --- Main ---
def main():
    logging.basicConfig(level=logging.WARNING)

    mgr = TransactionManager()

    if not mgr.start():
        print("[Main] Failed to start system.")
        return

    kb = KeyboardMonitor(mgr)
    kb.start()

    print("[Main] System Started. Press 'h' for help.")

    try:
        mgr.discover_and_subscribe()

        loops = 0
        while mgr.running:
            mgr.run_step()
            time.sleep(1.0)
            loops += 1
            if loops % 10 == 0:
                print(f"[Main] Loop {loops}...", end='\r')

    except KeyboardInterrupt:
        print("\n[Main] Interrupted.")
    except Exception as e:
        traceback.print_exc()
        print(f"[Main] Error: {e}")
    finally:
        kb.stop()
        print("[Main] Shutdown.")

if __name__ == "__main__":
    main()
