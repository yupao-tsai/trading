# import shioaji_patch  # Optional: Enable this if you encounter IndexError in fetch_contracts
import time
import uuid
import logging
import os
import threading
import json
from enum import Enum, auto
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
import traceback
from dotenv import load_dotenv

import shioaji as sj
from shioaji import constant as sj_constant
import ssl

# --- SSL Context Hack for macOS ---
try:
    _create_unverified_https_context = ssl._create_unverified_context
except AttributeError:
    pass
else:
    ssl._create_default_https_context = _create_unverified_https_context
# ----------------------------------

# --- Configuration & Enums ---

class TransactionState(Enum):
    INIT = auto()               # Created
    LEG1_SUBMITTED = auto()     # Stock order sent
    LEG1_PARTIAL = auto()       # Stock partially filled
    LEG1_FILLED = auto()        # Stock fully filled
    LEG2_SUBMITTED = auto()     # Future order sent
    LEG2_PARTIAL = auto()       # Future partially filled
    LEG2_FILLED = auto()        # Future fully filled
    COMPLETED = auto()          # Both legs filled
    CANCELLING = auto()         # Cancellation in progress
    CANCELLED = auto()          # Transaction cancelled
    FAILED = auto()             # Fatal error (requires manual intervention)

class SignalType(Enum):
    OPEN = auto()
    CLOSE = auto()
    REPAIR = auto()

@dataclass
class TradeIntent:
    """
    Generated by Strategy, consumed by TxManager.
    """
    type: SignalType
    stock_code: str
    future_code: str
    qty: int
    is_force: bool = False
    details: str = ""

@dataclass
class OrderStub:
    """
    Represents an order within a Transaction.
    Tracks the internal state and the exchange Order ID.
    """
    order_id: str = ""
    seqno: str = ""
    status: str = "INIT"  # Submitted, Filled, Cancelled, Failed
    filled_qty: int = 0
    price: float = 0.0
    action: str = ""
    error_msg: str = ""
    last_deal_qty_reported: int = 0

def _apply_fill(order: OrderStub, status_data: Dict) -> int:
    new_deal = int(status_data.get("deal_quantity", 0) or 0)
    # If deal_quantity is cumulative:
    delta = max(0, new_deal - order.last_deal_qty_reported)
    order.last_deal_qty_reported = new_deal
    order.filled_qty += delta
    return delta

# --- Market Data & Strategy ---

# --- Market Data & Strategy ---

@dataclass
class MarketSnapshot:
    code: str
    price: float = 0.0
    bid: float = 0.0
    ask: float = 0.0
    ts: float = 0.0
    volume: int = 0

class StrategyState:
    """
    Tracks EWMA statistics for a specific Pair.
    """
    def __init__(self, half_life_sec: float = 60.0):
        self.mean = 0.0
        self.var = 0.0
        self.std = 0.0
        self.samples = 0
        self.alpha = 2 / (half_life_sec + 1) # Simple approximate decay factor for tick-based
        # Ideally alpha should adjust by dt, but fixed step is acceptable for HFT-like polling
    
    def update(self, spread: float):
        if self.samples == 0:
            self.mean = spread
            self.var = 0.0
        else:
            diff = spread - self.mean
            incr = self.alpha * diff
            self.mean += incr
            self.var = (1 - self.alpha) * self.var + self.alpha * (diff * diff) # Estimation
            
        self.std = self.var ** 0.5
        self.samples += 1

class MarketData:
    def __init__(self):
        self.stocks: Dict[str, MarketSnapshot] = {}
        self.futures: Dict[str, MarketSnapshot] = {}
        self._lock = threading.Lock()
    
    def update_stock(self, tick: Any):
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            s = self.stocks.get(code, MarketSnapshot(code))
            
            # tick price
            if hasattr(tick, "close"): s.price = float(tick.close)
            elif hasattr(tick, "price"): s.price = float(tick.price)
            
            # bid/ask (best1) parsing
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    # bid_price might be list or scalar
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: s.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): s.bid = float(bp)
                        
                    if isinstance(ap, list) and ap: s.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): s.ask = float(ap)
                except: pass

            s.ts = time.time()
            self.stocks[code] = s

    def update_future(self, tick: Any):
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            s = self.futures.get(code, MarketSnapshot(code))
            
            if hasattr(tick, "close"): s.price = float(tick.close)
            elif hasattr(tick, "price"): s.price = float(tick.price)
            
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: s.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): s.bid = float(bp)
                        
                    if isinstance(ap, list) and ap: s.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): s.ask = float(ap)
                except: pass

            s.ts = time.time()
            self.futures[code] = s

    def get_stock(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.stocks.get(code)
    def get_future(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.futures.get(code)

class StrategyEngine:
    def __init__(self, market_data: MarketData):
        self.md = market_data
        self.stats: Dict[Tuple[str, str], StrategyState] = {}
        
        # Parameters
        self.Z_ENTRY = 2.0
        self.Z_EXIT = 0.5
        self.MIN_STD = 0.1 # Floor to prevent division by zero or huge Z on flat markets
        
    def _get_stats(self, stock_code: str, future_code: str) -> StrategyState:
        key = (stock_code, future_code)
        if key not in self.stats:
            self.stats[key] = StrategyState(half_life_sec=300) # 5-min half life
        return self.stats[key]
    
    def on_tick(self, stock_code: str, future_code: str) -> Optional[TradeIntent]:
        stk = self.md.get_stock(stock_code)
        fut = self.md.get_future(future_code)
        
        if not stk or not fut or stk.price <= 0 or fut.price <= 0:
            return None
            
        # 1. Calculate Spread (Mid Price if available)
        stk_px = stk.price
        if stk.bid > 0 and stk.ask > 0:
            stk_px = (stk.bid + stk.ask) / 2
            
        fut_px = fut.price
        if fut.bid > 0 and fut.ask > 0:
            fut_px = (fut.bid + fut.ask) / 2
            
        spread = fut_px - stk_px
        
        # 2. Update Stats
        stats = self._get_stats(stock_code, future_code)
        stats.update(spread)
        
        if stats.samples < 10: # Warmup
            return None
            
        # 3. Calculate Z-Score
        std = max(stats.std, self.MIN_STD)
        z_score = (spread - stats.mean) / std
        
        print(f"[Strategy] {stock_code} Spread={spread:.2f} Z={z_score:.2f} (µ={stats.mean:.2f} σ={std:.2f})")
        
        # 4. Generate Signals
        # Entry: Future is Expensive (High Spread) -> Short Future / Long Stock
        if z_score > self.Z_ENTRY:
            return TradeIntent(
                type=SignalType.OPEN,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"Z={z_score:.2f} > {self.Z_ENTRY}"
            )
            
        # Exit: Spread normalizes (Low Z)
        # Note: In vb01, 'CLOSE' intent usually implies checking if we HAVE a position.
        # But Strategy is pure, so it just says "Market is good for Closing".
        # TxManager decides if there's anything to close.
        elif z_score < self.Z_EXIT:
            return TradeIntent(
                type=SignalType.CLOSE,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"Z={z_score:.2f} < {self.Z_EXIT}"
            )
            
        return None

# --- Execution Engine (The Gateway) ---

class ExecutionEngine:
    """
    Handles connection to Shioaji, Authentication, and Raw Order Placement.
    Does NOT manage state. Just executes commands.
    """
    def __init__(self):
        print(f"[Execution] CWD: {os.getcwd()}")
        load_dotenv()
        
        # Init API
        # Use Simulation=True by default unless overridden
        self.api = sj.Shioaji(simulation=True)
        
        # Load Credentials (va3 style)
        self.person_id = os.getenv("Sinopack_PERSON_ID") 
        self.password = os.getenv("Sinopack_PASSWORD")
        self.ca_api_key = os.getenv("Sinopack_CA_API_KEY")
        self.ca_secret_key = os.getenv("Sinopack_CA_SECRET_KEY")
        self.ca_path = os.getenv("Sinopack_CA_PATH")
        self.ca_password = os.getenv("Sinopack_CA_PASSWORD")
        
        # Debug
        k_len = len(self.ca_api_key) if self.ca_api_key else 0
        s_len = len(self.ca_secret_key) if self.ca_secret_key else 0
        print(f"[Execution] Keys loaded. API_KEY len={k_len}, SECRET_KEY len={s_len}, PERSON_ID={self.person_id}")

        self.stock_account = None
        self.futopt_account = None
        
        # Callback for TxManager to hook into
        self.on_order_callback = None 
        
        # Track recent orders for 'o' command
        self.recent_orders = [] # List[Dict] 

    def get_contract(self, code: str, security_type: str = "Stock"):
        if security_type == "Stock":
             # Stocks is a dict-like map, but sometimes nested?
             # Standard Shioaji: api.Contracts.Stocks["2330"] works.
             return self.api.Contracts.Stocks.get(code)
        elif security_type == "Future":
             # Futures are category-based list of lists/tuples
             for cat in self.api.Contracts.Futures:
                 try: iter(cat)
                 except: continue
                 for c in cat:
                     if isinstance(c, tuple): c = c[1]
                     if getattr(c, "code", "") == code:
                         return c
        return None

    def login(self):
        print("[Execution] Connecting to Shioaji API...")
        if not self.ca_api_key or not self.ca_secret_key:
            print("[Execution] Fatal: Missing API Key/Secret.")
            return False

        try:
            # va3 login style
            self.api.login(
                api_key=self.ca_api_key, 
                secret_key=self.ca_secret_key,
                contracts_cb=lambda x: print(f"[Execution] Contracts loaded: {x}"),
                subscribe_trade=True
            )
            print("[Execution] Login success (Session Up). Waiting for contracts...")
            # Simple wait for contract load (va3 waits 5s)
            time.sleep(5.0)
        except Exception as e:
            print(f"[Execution] Login failed: {e}")
            return False

        # Activate CA (if needed for trading, though simulation usually doesn't need it but good to have)
        if self.ca_path and self.ca_password and self.person_id:
            try:
                self.api.activate_ca(ca_path=self.ca_path, ca_passwd=self.ca_password, person_id=self.person_id)
                print("[Execution] CA Activated.")
            except Exception as e:
                print(f"[Execution] CA Activation failed: {e}")
        
        # Set Accounts
        self.stock_account = self.api.stock_account
        self.futopt_account = self.api.futopt_account
        
        if not self.stock_account or not self.futopt_account:
            print("[Execution] Warning: Accounts not retrieved (Sim mode maybe?).")
            # In sim mode, sometimes account objects are empty or different.
            # But usually they exist.
        else:
            print(f"[Execution] Stock Account: {self.stock_account.account_id}")
            print(f"[Execution] Future Account: {self.futopt_account.account_id}")
        
        # Hook global callbacks
        self.api.set_order_callback(self._wrap_callback)
        return True

    def _wrap_callback(self, *args, **kwargs):
        """
        Routes Shioaji callbacks (supports both (topic, msg) and (OrderState) signatures).
        """
        if not self.on_order_callback:
            return

        # Case A: (topic, msg)
        if len(args) == 2 and isinstance(args[0], str):
            topic, msg = args
            if topic != "OrderState":
                return
            data = msg or {}

        # Case B: (state,) or similar object
        elif len(args) >= 1:
            state = args[0]
            # Convert to dict
            if isinstance(state, dict):
                data = state
            elif hasattr(state, "to_dict"):
                data = state.to_dict()
            else:
                data = getattr(state, "__dict__", {}) or {}
        else:
            return
            
        # Parse fields
        op = data.get("operation", {}) or {}
        order = data.get("order", {}) or {}
        status = data.get("status", {}) or {}

        op_code = op.get("op_code", "")
        op_msg = op.get("op_msg", "")

        seqno = order.get("seqno", "") or order.get("id", "") or order.get("ordno", "")
        oid = order.get("id", "") or order.get("ordno", "")
        
        # print(f"[OrderCB RAW] {data}") # Debug

        self.on_order_callback(oid, seqno, op_code, op_msg, status)

    def place_stock_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        """
        Returns Order ID (seqno) if successful, None otherwise.
        """
        try:
            contract = self.api.Contracts.Stocks[code]
            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.StockPriceType.LMT if price_type == "LMT" else sj_constant.StockPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC
            
            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.stock_account
                )
            )
            
            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Stock")
            
            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Stock Order Failed: {e}")
            return None

    def place_future_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        try:
            # Need to find contract carefully
            contract = self._resolve_future_contract(code)
            if not contract:
                print(f"[Execution] Future contract not found: {code}")
                return None

            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.FuturesPriceType.LMT if price_type == "LMT" else sj_constant.FuturesPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC
            
            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.futopt_account
                )
            )
            
            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Future")
            
            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Future Order Failed: {e}")
            return None

    def _resolve_future_contract(self, code: str):
        # Simplistic lookup, assuming standard code
        for cat in self.api.Contracts.Futures:
            try: iter(cat)
            except: continue
            for c in cat:
                if isinstance(c, tuple): c = c[1]
                if c.code == code:
                    return c
        return None

    def _track_order(self, seqno, code, action, price, qty, product):
        ts = time.strftime("%H:%M:%S")
        self.recent_orders.append({
            "time": ts,
            "seqno": seqno,
            "code": code,
            "action": action,
            "price": price,
            "qty": qty,
            "product": product,
            "status": "Submitted"
        })
        # Keep last 50
        if len(self.recent_orders) > 50:
            self.recent_orders.pop(0)

    def dump_orders(self) -> str:
        if not self.recent_orders:
             return "No orders yet."
        lines = ["\n=== RECENT ORDERS ==="]
        for o in self.recent_orders:
            lines.append(f"{o['time']} [{o['product']}] {o['action']} {o['code']} Q={o['qty']} P={o['price']} Seq={o['seqno']} St={o['status']}")
        return "\n".join(lines)

    def cancel_all_orders(self):
        """Cancel all pending orders in both accounts"""
        print("[Execution] Cancelling all open orders...")
        try:
            self.api.update_status()
            for trade in self.api.list_trades():
                if trade.status.status in ("PreSubmitted", "Submitted", "PartFilled"):
                    self.api.cancel_order(trade)
                    print(f"  Cancelled: {trade.contract.code} {trade.order.action}")
        except Exception as e:
            print(f"[Execution] Cancel failed: {e}")

# --- Core Transaction Classes ---

    def get_all_positions(self) -> Dict[str, int]:
        """Returns map of code -> net signed quantity"""
        pos_map = {}
        try:
             # Stocks
             if self.stock_account:
                 for p in self.api.list_positions(self.stock_account):
                     pos_map[p.code] = int(p.quantity)
             # Futures
             if self.futopt_account:
                 for p in self.api.list_positions(self.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj_constant.Action.Buy else -qty
                     pos_map[p.code] = net
        except: pass
        return pos_map

    def dump_positions(self) -> str:
        lines = ["\n=== POSITIONS ==="]
        try:
             # Force update
             if self.stock_account: self.api.update_status(self.stock_account)
             if self.futopt_account: self.api.update_status(self.futopt_account)
             
             # Stock
             if self.stock_account:
                 pos = self.api.list_positions(self.stock_account)
                 lines.append(f"Stocks ({len(pos)}):")
                 for p in pos:
                     # quantity is int. price is float.
                     lines.append(f"  {p.code} Qty={int(p.quantity)} avgP={p.price}")
            
             # Future
             if self.futopt_account:
                 pos = self.api.list_positions(self.futopt_account)
                 lines.append(f"Futures ({len(pos)}):")
                 for p in pos:
                     code = getattr(p, "code", "Unknown")
                     qty = getattr(p, "quantity", 0)
                     price = getattr(p, "price", 0)
                     # direction = getattr(p, "direction", "")
                     lines.append(f"  {code} Qty={int(qty)} avgP={price}")

        except Exception as e:
             lines.append(f"Error: {e}")
        return "\n".join(lines)

# --- Core Transaction Classes ---

class BaseTransaction:
    def __init__(self, intent: TradeIntent, tx_mgr):
        self.tx_id = str(uuid.uuid4())[:8]
        self.intent = intent
        self.mgr = tx_mgr
        self.state = TransactionState.INIT
        self.created_at = time.time()
        self.updated_at = time.time()
        self.state_enter_ts = time.time()
        
        self.stock_order = OrderStub()
        self.future_order = OrderStub()
        
        self.log(f"Transaction Created: {intent}")

    def log(self, msg: str):
        ts = time.strftime("%H:%M:%S")
        print(f"[{ts}] [Tx-{self.tx_id}] {msg}")

    def set_state(self, new_state: TransactionState, msg: str = ""):
        self.state = new_state
        self.state_enter_ts = time.time()
        if msg:
            self.log(msg)

    def update(self):
        self.updated_at = time.time()
        if self.state == TransactionState.INIT:
            self._step_init()
        elif self.state == TransactionState.LEG1_SUBMITTED:
            self._check_leg1_timeout()
        elif self.state == TransactionState.LEG1_FILLED:
            self._step_place_leg2()
        elif self.state == TransactionState.LEG2_SUBMITTED:
            self._check_leg2_timeout()

    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        # Match order by seqno
        # Leg 1
        if seqno == self.stock_order.seqno:
            self.log(f"Leg 1 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                # Check fill
                delta = _apply_fill(self.stock_order, status_data)
                if delta > 0:
                    self.log(f"Leg 1 Partial Fill: +{delta} (Total: {self.stock_order.filled_qty})")
                    if self.stock_order.filled_qty >= self.intent.qty:
                        self.state = TransactionState.LEG1_FILLED
                        self.stock_order.status = "Filled"
            else:
                 self.stock_order.status = "Failed"
                 self.stock_order.error_msg = msg
                 self.state = TransactionState.FAILED
                 self.log(f"Leg 1 FAILED: {msg}")

        # Leg 2
        elif seqno == self.future_order.seqno:
            self.log(f"Leg 2 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                delta = _apply_fill(self.future_order, status_data)
                if delta > 0:
                    self.log(f"Leg 2 Partial Fill: +{delta} (Total: {self.future_order.filled_qty})")
                    if self.future_order.filled_qty >= self.intent.qty:
                        self.state = TransactionState.COMPLETED
                        self.future_order.status = "Filled"
                        self.log("Transaction COMPLETE.")

    # --- Step Implementations ---

    def _step_init(self):
        # 0. Liquidity Check (Slippage Protection)
        snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
        if not snapshot: # No data yet
            self.log("No market data for Leg 1. Waiting...")
            return 
            
        # Check Ask Volume (Approximated by volume of last tick if no bidask? 
        # Ideally we need bidask snapshot. MarketData updates 'volume' from tick current volume, which is not ask volume.
        # But 'update_stock' receives 'bidask' object if available.
        # Let's assume MarketSnapshot has 'ask_volume' or we fetch from bidask.
        # For now, simplistic: Check if price exists.
        
        # Real Slippage Protection: Use Limit Price = Ask * 1.01 (1% buffer)
        # instead of Market Order.
        if snapshot.price <= 0:
            return 
            
        limit_price = snapshot.price * 1.01 # Buy 1% higher to ensure fill but capped slippage
        
        self.log(f"Placing Leg 1 (Stock {self.intent.stock_code}) Market Order...")
        
        action = "Buy" if self.intent.type == SignalType.OPEN else "Sell"
        
        seqno = self.mgr.execution.place_stock_order(
            self.intent.stock_code, action, 0, self.intent.qty, "MKT", "ROD"
        )
        
        if seqno:
            self.stock_order.seqno = seqno
            self.stock_order.status = "Submitted"
            self.state = TransactionState.LEG1_SUBMITTED
            self.log(f"Leg 1 Submitted SeqNo: {seqno}")
        else:
            self.state = TransactionState.FAILED
            self.log("Leg 1 Submission Failed")

    def _check_leg1_timeout(self):
        if time.time() - self.state_enter_ts > 90: # Increased from 30s to 90s for Sim Latency
            self.log("Leg 1 Timeout. Cancelling...")
            # Ideally cancel order via ExecutionEngine
            # self.mgr.execution.cancel_order(self.stock_order.seqno)
            self.state = TransactionState.FAILED

    def _step_place_leg2(self):
        # Dynamic Hedge: Hedge only what was filled
        filled_qty = self.stock_order.filled_qty
        if filled_qty <= 0:
            self.log("Leg 1 Filled Qty is 0? Strange.")
            self.state = TransactionState.FAILED
            return

        # Ratio Logic: Assuming 1:1 for simplicity or predefined ratio
        # In real TAIEX: 2 Stocks (2000 shares) : 1 Future (2000 shares) usually.
        # Let's assume self.intent.qty is in "Lots" (1 Lot = 1 Future + N Stocks)
        # But stock_order.filled_qty is raw shares or lots? Shioaji uses Lots (sheets).
        
        # If I bought filled_qty (sheets), how many futures?
        # Future Qty = filled_qty / 2 (Round?)
        # For safety/demo: hedge_qty = filled_qty (assuming 1:1)
        hedge_qty = filled_qty 
        
        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Qty={hedge_qty}...")
        action = "Sell" if self.intent.type == SignalType.OPEN else "Buy"
        
        # Slippage Protection for Leg 2:
        # We MUST fill this to hedge. Market order is safer for delta neutral, 
        # but Limit BID-1% is better protection.
        # Since we are SELLING future, we want to sell at Bid. 
        # Aggressive: Sell at Bid * 0.99
        snapshot = self.mgr.market_data.get_future(self.intent.future_code)
        # base_price = snapshot.price if snapshot and snapshot.price > 0 else 1000
        # limit_price = base_price * 0.99
        
        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Market Order...")

        seqno = self.mgr.execution.place_future_order(
            self.intent.future_code, action, 0, hedge_qty, "MKT", "IOC" # IOC to avoid hanging
        )
        
        if seqno:
            self.future_order.seqno = seqno
            self.future_order.status = "Submitted"
            self.set_state(TransactionState.LEG2_SUBMITTED)
            self.log(f"Leg 2 Submitted SeqNo: {seqno}")
        else:
            self.set_state(TransactionState.FAILED, "Leg 2 Submission Failed")

    def _check_leg2_timeout(self):
        if time.time() - self.state_enter_ts > 20: # Longer timeout for leg 2
            self.log("Leg 2 Timeout. Cancelling...")
            # self.mgr.execution.cancel_order(self.future_order.seqno)
            self.set_state(TransactionState.FAILED)

class OpenArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Open:
    1. Buy Stock
    2. Sell Future
    """
    pass

class CloseArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Exit:
    1. Buy Future (Close Short) - Priority to remove unlimited risk
    2. Sell Stock (Close Long)
    """
    def update(self):
        # 1. INIT -> Buy Future
        if self.state == TransactionState.INIT:
            # Liquidity Check (Future Ask)
            snapshot = self.mgr.market_data.get_future(self.intent.future_code)
            if not snapshot or snapshot.price <= 0:
                 self.log("No Future Price. Waiting...")
                 return
            
            # Limit Price = Ask * 1.01 (Buy aggressive)
            # limit_price = snapshot.price * 1.01 
            self.log(f"Closing: Buying Future {self.intent.future_code} Market Order...")
            
            seqno = self.mgr.execution.place_future_order(
                self.intent.future_code, "Buy", 0, self.intent.qty, "MKT", "IOC" 
            )
            
            if seqno:
                self.future_order.seqno = seqno
                self.future_order.status = "Submitted"
                self.set_state(TransactionState.LEG1_SUBMITTED)
            else:
                 self.set_state(TransactionState.FAILED, "Future Buy Failed")

        # 1.5 Timeout Check for Future Buy
        elif self.state == TransactionState.LEG1_SUBMITTED:
             if time.time() - self.state_enter_ts > 10:
                  self.log("Close Leg 1 (Future) Timeout. Cancelling...")
                  self.set_state(TransactionState.FAILED)

        # 2. LEG1_FILLED -> Sell Stock
        elif self.state == TransactionState.LEG1_FILLED:
            filled_qty = self.future_order.filled_qty
            # Hedge Ratio: 1 Future -> 1 Lot Stock (Simplicity)
            hedge_qty = filled_qty
            
            self.log(f"Closing: Selling Stock {self.intent.stock_code} Qty={hedge_qty}...")
            
            # Sell Stock Aggressive (Bid * 0.99)
            snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
            # base_price = snapshot.price if snapshot and snapshot.price > 0 else 1000
            # limit_price = base_price * 0.99
            
            self.log(f"Closing: Selling Stock {self.intent.stock_code} Market Order...")
            
            seqno = self.mgr.execution.place_stock_order(
                self.intent.stock_code, "Sell", 0, hedge_qty, "MKT", "ROD"
            )
            
            if seqno:
                self.stock_order.seqno = seqno
                self.set_state(TransactionState.LEG2_SUBMITTED)
            else:
                self.set_state(TransactionState.FAILED, "Stock Sell Failed")
        
        elif self.state == TransactionState.LEG2_FILLED:
            self.set_state(TransactionState.COMPLETED, "Arbitrage Close Complete")

    # CloseArbitrageTransaction overrides update and on_order_update completely
    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        # Leg1 = Future buy, Leg2 = Stock sell
        # Do NOT call super() here to avoid logic conflict
        
        if seqno == self.future_order.seqno:
            self.log(f"[Close] Future Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Future leg failed: {msg}")
                return
            
            delta = _apply_fill(self.future_order, status_data)
            if delta > 0:
                self.log(f"[Close] Future fill +{delta} (total {self.future_order.filled_qty})")
            
            if self.future_order.filled_qty >= self.intent.qty:
                self.set_state(TransactionState.LEG1_FILLED, "Future leg filled")

        elif seqno == self.stock_order.seqno:
            self.log(f"[Close] Stock Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Stock leg failed: {msg}")
                return
            
            delta = _apply_fill(self.stock_order, status_data)
            if delta > 0:
                self.log(f"[Close] Stock fill +{delta} (total {self.stock_order.filled_qty})")
            
            if self.stock_order.filled_qty >= self.intent.qty:
                self.set_state(TransactionState.COMPLETED, "Arbitrage Close Complete")

# --- Pair Discovery ---

class PairDiscovery:
    def __init__(self, api: sj.Shioaji):
        self.api = api
        
    def _load_local_history(self) -> Tuple[set, set]:
        """
        Reads local order_history.jsonl to find recently traded codes.
        Returns (local_stocks, local_futures)
        """
        l_stocks = set()
        l_futures = set()
        path = "order_history.jsonl"
        if not os.path.exists(path):
            return l_stocks, l_futures
            
        print(f"[Discovery] Reading local history from {path}...")
        try:
            with open(path, "r", encoding="utf-8") as f:
                # Read last 100 lines is usually enough, but let's read all simply
                lines = f.readlines()
                # Process in reverse to get latest
                for line in reversed(lines):
                    try:
                        rec = json.loads(line)
                        f_code = rec.get("fut_code")
                        s_code = rec.get("stock_code")
                        if f_code: l_futures.add(f_code)
                        if s_code: l_stocks.add(s_code)
                    except: pass
            print(f"[Discovery] Recovered from history - Stocks: {len(l_stocks)}, Futures: {len(l_futures)}")
            # Debug: print sample
            if l_futures: print(f"[Discovery] History Futures Sample: {list(l_futures)[:5]}")
        except Exception as e:
            print(f"[Discovery] History load failed: {e}")
            
        return l_stocks, l_futures

    def scan(self, limit: int = 5) -> List[Tuple[str, str]]:
        """
        Scans for valid Stock-Future pairs. 
        Priority:
        1. Pairs where we hold positions (Stock or Future).
        2. Popular pairs (e.g. 2330) if space allows.
        """
        found = [] # List[(stock_code, future_code)]
        held_stocks = set()
        held_futures = set()
        
        print("[Discovery] Syncing positions (wait 3s)...")
        try:
            if hasattr(self.api, "update_status"):
                try: self.api.update_status(self.api.stock_account)
                except: pass
                try: self.api.update_status(self.api.futopt_account) 
                except: pass
            time.sleep(3.0)
        except Exception as e:
            print(f"[Discovery] Sync failed: {e}")

        # Load Local History to supplement API
        h_stocks, h_futures = self._load_local_history()
        
        print("[Discovery] Scanning positions first...")
        
        # 1. Get Held Positions (API + History)
        try:
            if self.api.stock_account:
                pos = self.api.list_positions(self.api.stock_account)
                for p in pos:
                    code = getattr(p, "code", "")
                    if code: held_stocks.add(code)
            
            if self.api.futopt_account:
                pos = self.api.list_positions(self.api.futopt_account)
                for p in pos:
                    code = getattr(p, "code", "")
                    if code: held_futures.add(code)

        except Exception as e:
            print(f"[Discovery] API Position scan failed: {e}")

        # Merging history causes Zombie pairs to block new ones.
        # We only want to monitor what we ACTUALLY hold right now.
        # held_stocks.update(h_stocks)
        # held_futures.update(h_futures)
        
        print(f"[Discovery] Active Held Stocks: {held_stocks}")
        print(f"[Discovery] Active Held Futures: {held_futures}")

        # 2. Map Futures to Stocks
        # 2. Map Futures to Stocks & Volume Scan
        print("[Discovery] Scanning contracts for candidates...")
        
        # A) Find all stocks that HAVE a future
        candidates_map = {} # stock_code -> future_contract
        try:
            for category in self.api.Contracts.Futures:
                try: iter(category)
                except: continue
                for contract in category:
                    if isinstance(contract, tuple): contract = contract[1]
                    if not contract: continue
                    f_code = getattr(contract, "code", "")
                    u_code = getattr(contract, "underlying_code", "") 
                    
                    if not u_code: continue
                    # Only map if we haven't seen this stock, OR if this future is 'better' (e.g. Standard vs Mini)
                    # For simplicity, we take the first valid one we find, or maybe prefer R1/Specific if implementing logic.
                    # VB01 Simplicity: Store first valid future.
                    if u_code not in candidates_map:
                        candidates_map[u_code] = contract

        except Exception as e:
            print(f"[Discovery] Contract map failed: {e}")

        # B) Add Held Pairs to 'found' immediately (Priority 1)
        for s_code in held_stocks:
            if s_code in candidates_map:
                f_c = candidates_map[s_code]
                pair = (s_code, f_c.code)
                if pair not in found:
                    found.append(pair)
        
        # C) Volume Scan for remaining slots (Priority 2)
        remaining = limit - len(found)
        if remaining > 0:
            print(f"[Discovery] Need {remaining} more pairs. Fetching volumes for {len(candidates_map)} candidates...")
            
            # Get objects for snapshots
            stk_contracts = []
            valid_u_codes = []
            none_count = 0
            
            for u_code in candidates_map.keys():
                try:
                    c = self.api.Contracts.Stocks[u_code]
                    if c is None:
                        # Evidence: Log the problematic code
                        # print(f"[Debug] Stock {u_code} returned None object")
                        none_count += 1
                        continue
                    stk_contracts.append(c)
                    valid_u_codes.append(u_code)
                except: pass
            
            if none_count > 0:
                print(f"[Discovery] Filtered out {none_count} None/Invalid contracts to prevent crash.")

            # Batch Snapshot (Chunked)
            vol_map = {} # u_code -> volume
            
            # Simulation Fallback Weights (Top 30 Taiwan Stock Weights)
            # Used when API returns 0 volume in Sim
            blue_chips = {
                '2330': 100000, '2317': 90000, '2454': 85000, '2303': 80000, '2881': 75000,
                '1301': 70000, '1303': 69000, '2882': 68000, '2002': 67000, '1216': 66000,
                '2412': 65000, '2308': 64000, '2891': 63000, '3231': 62000, '2382': 61000,
                '2886': 60000, '2884': 59000, '2357': 58000, '1101': 57000, '2892': 56000,
                '5880': 55000, '2880': 54000, '3008': 53000, '2603': 52000, '3711': 51000,
                '2885': 50000, '2207': 49000, '3045': 48000, '5876': 47000, '2301': 46000
            }

            # PRE-FILL: Ensure we have data even if API crashes
            for bc_code, bc_vol in blue_chips.items():
                if bc_code in candidates_map:
                     vol_map[bc_code] = bc_vol

            chunk_size = 200
            for i in range(0, len(stk_contracts), chunk_size):
                chunk = stk_contracts[i:i+chunk_size]
                try:
                    snaps = self.api.snapshots(chunk) # Corrected from snapshot -> snapshots
                    for s in snaps:
                        price = float(getattr(s, 'close', 0) or getattr(s, 'reference_price', 0) or 0)
                        
                        # Price Filter: Exclude if > 500
                        if price > 500:
                            # print(f"[Discovery] Filtered outdated pair {s.code} (Price={price} > 500)")
                            vol_map[s.code] = 0
                            continue

                        v = int(getattr(s, 'total_volume', 0) or 0)
                        # Fallback for Sim
                        if v == 0 and s.code in blue_chips:
                             v = blue_chips[s.code]
                        vol_map[s.code] = v
                except Exception as e:
                    print(f"[Discovery] Snapshot chunk failed: {e}")
            
            # Sort by Volume Desc
            sorted_candidates = sorted(valid_u_codes, key=lambda x: vol_map.get(x, 0), reverse=True)
            
            # Pick Top N
            for u_code in sorted_candidates:
                if len(found) >= limit: break
                
                # Check if already added via holdings
                is_added = any(p[0] == u_code for p in found)
                if is_added: continue
                
                f_c = candidates_map[u_code]
                found.append((u_code, f_c.code))
                print(f"[Discovery] Added Top Vol Pair: {u_code} (Vol={vol_map.get(u_code,0)})")

            if not found:
                # If no positions found, try 2330
                if "2330" in self.api.Contracts.Stocks:
                    # Find 2330 Future
                    for category in self.api.Contracts.Futures:
                        try: iter(category)
                        except: continue
                        for c in category:
                            if isinstance(c, tuple): c = c[1]
                            if getattr(c, "underlying_code", "") == "2330":
                                found.append(("2330", c.code))
                                break
                        if found: break
            
            # Limit
            final_list = found[:limit]
            print(f"[Discovery] Final Pairs: {final_list}")
            return final_list
            


import sys

# --- Transaction Manager ---

class TransactionManager:
    def __init__(self):
        self.market_data = MarketData()
        self.strategy = StrategyEngine(self.market_data)
        self.execution = ExecutionEngine()
        
        self.active_transactions: Dict[str, BaseTransaction] = {}
        self.completed_transactions: List[BaseTransaction] = []
        self.cooldowns: Dict[str, float] = {} # code -> expiry timestamp
        
        self.monitored_pairs: List[Tuple[str, str]] = [] # (stk, fut)
        
        # Connect Execution Event
        self.execution.on_order_callback = self.on_execution_event
        
        self.running = False

    def start(self):
        if not self.execution.login():
            return False
        
        self.running = True
        
        # Install Market Data Callbacks
        @self.execution.api.on_bidask_stk_v1(bind=True)
        def _on_stk_callback(self_api, exchange, bidask):
            self.market_data.update_stock(bidask)
            
        @self.execution.api.on_bidask_fop_v1(bind=True)
        def _on_fop_callback(self_api, exchange, bidask):
            self.market_data.update_future(bidask)

        @self.execution.api.on_tick_stk_v1(bind=True)
        def _on_tick_stk_callback(self_api, exchange, tick):
            self.market_data.update_stock(tick)
            
        @self.execution.api.on_tick_fop_v1(bind=True)
        def _on_tick_fop_callback(self_api, exchange, tick):
            self.market_data.update_future(tick)
            
        return True

    def stop(self):
        self.running = False
    
    def discover_and_subscribe(self):
        discovery = PairDiscovery(self.execution.api)
        # Scan for pairs (va3 uses 80, we use 20 for safety in vb01 initially)
        self.monitored_pairs = discovery.scan(limit=20)
        
        if not self.monitored_pairs:
            print("[TxMgr] No pairs found. Using Fallback (2330).")
            # Find a CDF contract manually to enable demo
            fut_code = "CDF" # Default prefix
            for cat in self.execution.api.Contracts.Futures:
                for c in cat:
                    if getattr(c, 'code', '').startswith("CDF"):
                        fut_code = c.code
                        break
                if fut_code != "CDF": break
            
            if fut_code != "CDF":
                 self.monitored_pairs = [("2330", fut_code)]
            else:
                 print("[TxMgr] Fallback failed. No pairs.")
                 return

        print(f"[TxMgr] Subscribing to {len(self.monitored_pairs)} pairs...")
        for s, f in self.monitored_pairs:
            print(f"[TxMgr] Subscribed: {s} <-> {f}")
            c_stk = self.execution.get_contract(s, "Stock")
            c_fut = self.execution.get_contract(f, "Future")
            
            # Subscribe Tick & Legacy BidAsk
            self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.Tick)
            self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.BidAsk)
            self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.Tick)
            self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.BidAsk)
            

    def _check_position_safety(self, intent: TradeIntent) -> bool:
        # Use ExecutionEngine's helper
        positions = self.execution.get_all_positions()
        
        s_qty = positions.get(intent.stock_code, 0)
        f_qty = positions.get(intent.future_code, 0)
        
        if intent.type == SignalType.OPEN:
             # Reject if we already have exposure
             if abs(s_qty) > 0 or abs(f_qty) > 0:
                  print(f"[TxMgr] REJECT OPEN: Existing Position found {intent.stock_code}={s_qty}, {intent.future_code}={f_qty}")
                  return False
        
        elif intent.type == SignalType.CLOSE:
             # Strict Check: Close requires Stock > 0 AND Future < 0 (Arbitrage Position)
             # If we are net Long Future, CLOSE (Buy Future) makes it WORSE.
             if not (s_qty > 0 and f_qty < 0):
                  print(f"[TxMgr] REJECT CLOSE: Position not arbitrage-shape (s={s_qty}, f={f_qty}). Use Repair instead.")
                  # Apply Cooldown to silence noise
                  self.cooldowns[intent.stock_code] = time.time() + 60
                  self.cooldowns[intent.future_code] = time.time() + 60
                  return False
                  
             # Reject if we have NO exposure (Duplicate Close)
             if s_qty == 0 and f_qty == 0:
                  # print(f"[TxMgr] REJECT CLOSE: No Position to close.")
                  return False
                  
        return True

    def request_new_transaction(self, intent: TradeIntent) -> bool:
        if intent.stock_code in self.active_transactions:
            return False
            
        # Cooldown check
        for k in (intent.stock_code, intent.future_code):
             if k in self.cooldowns and time.time() < self.cooldowns[k]:
                 return False

        # Safety Check (Positions)
        if not self._check_position_safety(intent):
             return False
        
        print(f"[TxMgr] ACCEPT: Starting new transaction for {intent.stock_code} ({intent.details})")
        
        # Factory Logic
        if intent.type == SignalType.OPEN:
            tx = OpenArbitrageTransaction(intent, self)
        elif intent.type == SignalType.CLOSE:
            tx = CloseArbitrageTransaction(intent, self)
        else:
            tx = BaseTransaction(intent, self) 
            
        self.active_transactions[intent.stock_code] = tx
        return True

    def run_step(self):
        # 0. Force Status Update (Sim Workaround)
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except: pass

        # 1. Update Active Transactions
        codes = list(self.active_transactions.keys())
        for code in codes:
            tx = self.active_transactions[code]
            tx.update()
            
            if tx.state in [TransactionState.COMPLETED, TransactionState.FAILED, TransactionState.CANCELLED]:
                print(f"[TxMgr] Archiving Tx {tx.tx_id}")
                self.completed_transactions.append(tx)
                
                # If Failed (Timeout), apply Cooldown to prevent spiral
                if tx.state == TransactionState.FAILED:
                     print(f"[TxMgr] Apply Cooldown (60s) for {code}")
                     self.cooldowns[code] = time.time() + 60
                
                if code in self.active_transactions:
                    del self.active_transactions[code]

        # 2. Run Strategy (Scanning)
        for stk, fut in self.monitored_pairs:
            # Only scan if not already active
            if stk not in self.active_transactions:
                intent = self.strategy.on_tick(stk, fut)
                if intent:
                    self.request_new_transaction(intent)

    def repair_positions(self):
        print("\n[TxMgr] === REPAIRING POSITIONS (Aggressive) ===")
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except: pass

        stk_map = {}
        if self.execution.stock_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.stock_account):
                     stk_map[p.code] = int(p.quantity)
             except: pass
        
        fut_map = {} 
        if self.execution.futopt_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj.constant.Action.Buy else -qty
                     fut_map[p.code] = net
             except: pass

        for s, f in self.monitored_pairs:
             s_qty = stk_map.get(s, 0)
             f_net = fut_map.get(f, 0)
             
             # 1. Naked Long Future -> Sell
             if f_net > 0:
                  print(f"[Repair] {f} is Net Long ({f_net}). Closing (Sell)...")
                  self.execution.place_future_order(f, "Sell", 0, abs(f_net), "MKT", "IOC")
             
             # 2. Naked Short Future (No Stock) -> Buy
             elif f_net < 0:
                  if s_qty == 0:
                       print(f"[Repair] {f} is Naked Short ({f_net}). Closing (Buy)...")
                       self.execution.place_future_order(f, "Buy", 0, abs(f_net), "MKT", "IOC")

             # 3. Naked Stock (No Future) -> Sell
             if s_qty > 0 and f_net == 0:
                  print(f"[Repair] {s} is Naked Stock ({s_qty}). Closing (Sell)...")
                  self.execution.place_stock_order(s, "Sell", 0, s_qty, "MKT", "ROD")

        print("[Repair] Scan complete.\n")

    def repair_flatten_unpaired_futures(self, dry_run: bool = True, cooldown_sec: int = 30):
        """
        Flatten futures if stock is 0 and future != 0.
        dry_run=True: only print plan; no orders.
        """
        print(f"\n[TxMgr] Fixing Unpaired Futures... (dry_run={dry_run})")

        # 0) Force refresh
        try:
            if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
            if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
            time.sleep(1.0)
        except:
            pass

        # 1) Build holdings
        s_holdings = {}
        if self.execution.stock_account:
            try:
                for p in self.execution.api.list_positions(self.execution.stock_account):
                    s_holdings[p.code] = int(p.quantity)
            except:
                pass

        f_holdings = {}
        if self.execution.futopt_account:
            try:
                for p in self.execution.api.list_positions(self.execution.futopt_account):
                    qty = int(p.quantity)
                    net = qty if p.direction == sj.constant.Action.Buy else -qty
                    f_holdings[p.code] = net
            except:
                pass

        # 2) Flatten
        for s, f in self.monitored_pairs:
            s_qty = s_holdings.get(s, 0)
            f_qty = f_holdings.get(f, 0)

            if s_qty != 0 or f_qty == 0:
                continue

            # cooldown per stock (silence repeated repair on same name)
            exp = self.cooldowns.get(s, 0)
            if time.time() < exp:
                continue

            action = "Sell" if f_qty > 0 else "Buy"
            closing_qty = abs(f_qty)

            print(f"[Repair] {s}/{f}: Stock=0, Fut={f_qty} -> {action} {closing_qty} (flatten)")

            # apply cooldown even in dry-run (avoid spam)
            self.cooldowns[s] = time.time() + cooldown_sec

            if dry_run:
                continue

            self.execution.place_future_order(f, action, 0, closing_qty, "MKT", "IOC")

        print("[Repair] Done.\n")
                  
    def on_execution_event(self, oid, seqno, op_code, op_msg, status_data):
        # Dispatch to active transaction
        found_active = False
        for tx in self.active_transactions.values():
            if (tx.stock_order.seqno and tx.stock_order.seqno == seqno) or \
               (tx.future_order.seqno and tx.future_order.seqno == seqno):
                tx.on_order_update(seqno, op_code, msg=op_msg, status_data=status_data)
                found_active = True
                break
        
        if found_active:
            return

        # Check for Late Fills in Archived Transactions
        # If we receive a Fill for a transaction we already timed out, we must repair.
        deal_qty = int(status_data.get("deal_quantity", 0))
        if deal_qty > 0:
             for tx in self.completed_transactions:
                 if (tx.stock_order.seqno and tx.stock_order.seqno == seqno) or \
                    (tx.future_order.seqno and tx.future_order.seqno == seqno):
                      print(f"\n[TxMgr] ⚠️ CRITICAL: Late Fill detected for Archived Tx {tx.tx_id} (Seq={seqno})!")
                      print(f"[TxMgr] This causes a Naked Position. Triggering Auto-Repair...")
                      self.repair_positions()
                      break

    def dump_status(self) -> str:
        lines = ["\n=== STATUS ==="]
        lines.append(f"Monitored Pairs: {len(self.monitored_pairs)}")
        for s, f in self.monitored_pairs:
            stk_data = self.market_data.get_stock(s)
            fut_data = self.market_data.get_future(f)
            s_price = stk_data.price if stk_data else 0.0
            f_price = fut_data.price if fut_data else 0.0
            
            # Strategy Info
            stat = self.strategy.stats.get((s, f))
            extra = "(No Stats)"
            if stat and stat.samples > 0:
                 spread = f_price - s_price
                 # Access Strategy constants safely
                 min_std = getattr(self.strategy, 'MIN_STD', 1.0)
                 std = max(stat.std, min_std)
                 z = (spread - stat.mean) / std
                 extra = f"Sprd={spread:.1f} Z={z:.2f} (Avg={stat.mean:.1f})"
            
            lines.append(f"  {s}({s_price}) <-> {f}({f_price}) | {extra}")
            
        lines.append(f"\nActive Transactions: {len(self.active_transactions)}")
        for code, tx in self.active_transactions.items():
            lines.append(f"  [{code}] State={tx.state.name} Created={time.strftime('%H:%M:%S', time.localtime(tx.created_at))}")
            lines.append(f"    Leg1: {tx.stock_order.status} ({tx.stock_order.filled_qty}/{tx.intent.qty})")
            lines.append(f"    Leg2: {tx.future_order.status} ({tx.future_order.filled_qty})")

        lines.append(self.execution.dump_positions())
            
        return "\n".join(lines)

# --- Interactive Keyboard ---
try:
    import termios, tty, select
    _HAS_TERMIOS = True
except Exception:
    _HAS_TERMIOS = False

try:
    import msvcrt
    _HAS_MS = True
except Exception:
    _HAS_MS = False

class KeyboardMonitor(threading.Thread):
    """
    p -> print positions / transactions
    o -> print orders
    h -> help
    q -> quit
    x -> repair (close naked positions)
    """
    def __init__(self, manager: 'TransactionManager', poll_sec: float = 0.5):
        super().__init__(daemon=True)
        self.mgr = manager
        self.poll_sec = poll_sec
        self._stop_evt = threading.Event()

    def stop(self):
        self._stop_evt.set()

    def run(self):
        self._print_help_once()
        if _HAS_MS:
            self._run_windows()
        elif _HAS_TERMIOS:
            self._run_posix()
        else:
             print("[Keyboard] No interactive support (no termios/msvcrt).")
             while not self._stop_evt.is_set():
                 time.sleep(1.0)

    def _print_help_once(self):
        print("\n[Keyboard] p=status, o=orders, h=help, q=quit\n", flush=True)

    def _handle_key(self, ch: str):
        ch = (ch or "").strip().lower()
        if not ch: return
        
        if ch == "p":
            print(self.mgr.dump_status(), flush=True)
        elif ch == "o":
            # Assuming dump_orders exists or we implement it
            print(self.mgr.execution.dump_orders(), flush=True) 
        elif ch == "x":
            print("[Keyboard] 'x' pressed: Running full repair scan (Dry Run)...")
            self.mgr.repair_positions() # This already prints logic but doesn't have a dry_run arg? Let's check.
            # Actually repair_positions places orders directly on lines 1177/1183/1188. 
            # Wait, line 1139 definition doesn't take dry_run. We need to check if we can add it or if we should just trust X=Real.
            # Let's just map 'X' to repair_positions() for now as a "Force Fix".
        elif ch == "X":
            print("[Keyboard] 'X' pressed: FORCE REPAIR started...")
            self.mgr.repair_positions()
        elif ch == "h":
            self._print_help_once()
        elif ch == "q":
            print("\n[Keyboard] Quit requested...", flush=True)
            self.mgr.stop()
            self.stop()
            # Cancel all open orders before quitting
            print("[Keyboard] Cancelling ALL open orders...", flush=True)
            self.mgr.execution.cancel_all_orders()
            # We might need to interrupt main loop main_stop_event
            # But Main is running via checking mgr.running?
            # We'll set a flag in mgr.
            
    def _run_windows(self):
        while not self._stop_evt.is_set():
            if msvcrt.kbhit():
                ch = msvcrt.getwch()
                self._handle_key(ch)
            time.sleep(self.poll_sec)

    def _run_posix(self):
        fd = sys.stdin.fileno()
        try:
            old = termios.tcgetattr(fd)
        except Exception:
            return

        try:
            tty.setcbreak(fd)
            while not self._stop_evt.is_set():
                r, _, _ = select.select([sys.stdin], [], [], self.poll_sec)
                if r:
                    ch = sys.stdin.read(1)
                    self._handle_key(ch)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

# --- Main ---
def main():
    # Setup Logging
    logging.basicConfig(level=logging.WARNING)
    
    mgr = TransactionManager()
    
    # Start System
    if not mgr.start():
        print("[Main] Failed to start system.")
        return

    # Start Keyboard Monitor
    kb = KeyboardMonitor(mgr)
    kb.start()
    
    print("[Main] System Started. Press 'h' for help.")
    
    try:
        # Initial Discovery
        mgr.discover_and_subscribe()
        
        # Main Loop
        loops = 0
        while mgr.running:
            mgr.run_step()
            time.sleep(1.0)
            loops += 1
            if loops % 10 == 0:
                print(f"[Main] Loop {loops}...", end='\r')
                
    except KeyboardInterrupt:
        print("\n[Main] Interrupted.")
    except Exception as e:
        traceback.print_exc()
        print(f"[Main] Error: {e}")
    finally:
        kb.stop()
        print("[Main] Shutdown.")
        
if __name__ == "__main__":
    main()
