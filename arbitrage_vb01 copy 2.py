# import shioaji_patch  # Optional: Enable this if you encounter IndexError in fetch_contracts
import time
import uuid
import logging
import os
import threading
import json
import sys
from enum import Enum, auto
from typing import Dict, List, Optional, Any, Tuple, Callable
from dataclasses import dataclass, field
import traceback
from dotenv import load_dotenv

import shioaji as sj
from shioaji import constant as sj_constant
import ssl
import math

# --- SSL Context Hack for macOS ---
try:
    _create_unverified_https_context = ssl._create_unverified_context
except AttributeError:
    pass
else:
    ssl._create_default_https_context = _create_unverified_https_context

# --- Helpers ---
def resolve_stock_contract(api, code: str):
    try:
        c = api.Contracts.Stocks.get(code)
        if c: return c
    except: pass
    try:
        return api.Contracts.Stocks[code]
    except: return None

def resolve_future_contract(api, code: str):
    """Robustly search nested futures contracts."""
    fut_root = api.Contracts.Futures
    # 1. Try direct .get
    try:
        c = fut_root.get(code)
        if c: return c
    except: pass

    # 2. Walk attributes (Exchange -> Product -> Contract)
    for exch_name in dir(fut_root):
        if exch_name.startswith("_"): continue
        exch = getattr(fut_root, exch_name, None)
        if exch is None: continue
        
        # exch might be dict-like
        try: keys = list(exch.keys())
        except: keys = None
        
        if keys is not None:
             for k in keys:
                 prod = exch.get(k)
                 if prod is None: continue
                 # prod might be dict-like of contracts
                 try:
                     for kk in prod.keys():
                         c = prod.get(kk)
                         if c and getattr(c, "code", "") == code: return c
                 except:
                     if getattr(prod, "code", "") == code: return prod
        else:
             # Not dict-like, maybe iterable or contract itself
             if getattr(exch, "code", "") == code: return exch
             try:
                 for item in exch:
                     c = item[1] if isinstance(item, tuple) else item
                     if c and getattr(c, "code", "") == code: return c
             except: pass
    return None

# --- Configuration & Enums ---

class TransactionState(Enum):
    INIT = auto()               # Created
    LEG1_SUBMITTED = auto()     # Stock order sent
    LEG1_PARTIAL = auto()       # Stock partially filled
    LEG1_FILLED = auto()        # Stock fully filled
    LEG2_SUBMITTED = auto()     # Future order sent
    LEG2_PARTIAL = auto()       # Future partially filled
    LEG2_FILLED = auto()        # Future fully filled
    COMPLETED = auto()          # Both legs filled
    CANCELLING = auto()         # Cancellation in progress
    CANCELLED = auto()          # Transaction cancelled
    FAILED = auto()             # Fatal error (requires manual intervention)

class SignalType(Enum):
    OPEN = auto()
    CLOSE = auto()
    REPAIR = auto()

@dataclass
class TradeIntent:
    """
    Generated by Strategy, consumed by TxManager.
    """
    type: SignalType
    stock_code: str
    future_code: str
    qty: int
    is_force: bool = False
    details: str = ""

@dataclass
class OrderStub:
    """
    Represents an order within a Transaction.
    Tracks the internal state and the exchange Order ID.
    """
    order_id: str = ""
    seqno: str = ""
    status: str = "INIT"  # Submitted, Filled, Cancelled, Failed
    filled_qty: int = 0
    price: float = 0.0
    action: str = ""
    error_msg: str = ""
    last_deal_qty_reported: int = 0

def _get_deal_qty(status: Dict) -> int:
    """Robustly extract deal quantity."""
    for k in ("deal_quantity", "deal_qty", "filled_qty", "dealQuantity"):
        v = status.get(k, None)
        if v is not None:
            try: return int(v)
            except: pass
    return 0

def _apply_fill(order: OrderStub, status_data: Dict) -> int:
    q = _get_deal_qty(status_data)
    delta = 0
    # Shioaji 'deal_quantity' is usually cumulative in OrderState.
    # If q is >= last_reported, treat as cumulative update.
    if q >= order.last_deal_qty_reported:
        delta = q - order.last_deal_qty_reported
        order.last_deal_qty_reported = q
        order.filled_qty += delta
    else:
        # q < last reported. This might be an incremental 'Deal' event or a reset?
        # Safe fallback: treat as incremental if small positive?
        # For now, ignore to avoid double counting if status is mixed.
        pass
    return delta

# --- Market Data & Strategy ---

# --- Market Data & Strategy ---

@dataclass
class MarketSnapshot:
    code: str
    price: float = 0.0
    bid: float = 0.0
    ask: float = 0.0
    ts: float = 0.0
    volume: int = 0

class StrategyState:
    """
    Tracks EWMA statistics for a specific Pair.
    """
    def __init__(self, half_life_sec: float = 60.0):
        self.mean = 0.0
        self.var = 0.0
        self.std = 0.0
        self.samples = 0
        self.half_life = half_life_sec
        self.last_ts = 0.0
    
    def update(self, spread: float):
        now = time.time()
        if self.samples == 0:
            self.mean = spread
            self.var = 0.0
            self.last_ts = now
        else:
            dt = now - self.last_ts
            if dt <= 0: dt = 0.001 # Prevent zero division or weirdness
            
            # alpha = 1 - exp(-ln(2)*dt/half_life)
            alpha = 1.0 - math.exp(-0.6931 * dt / self.half_life)
            
            diff = spread - self.mean
            incr = alpha * diff
            self.mean += incr
            self.var = (1 - alpha) * self.var + alpha * (diff * diff) # Estimation
            self.last_ts = now
            
        self.std = self.var ** 0.5
        self.samples += 1

class MarketData:
    def __init__(self, on_tick_callback: Optional[Callable[[str], None]] = None):
        self.stocks: Dict[str, MarketSnapshot] = {}
        self.futures: Dict[str, MarketSnapshot] = {}
        self._lock = threading.Lock()
        self.on_tick_callback = on_tick_callback
    
    def update_stock(self, tick: Any):
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            s = self.stocks.get(code, MarketSnapshot(code))
            
            # tick price
            if hasattr(tick, "close"): s.price = float(tick.close)
            elif hasattr(tick, "price"): s.price = float(tick.price)
            
            # bid/ask (best1) parsing
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    # bid_price might be list or scalar
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: s.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): s.bid = float(bp)
                        
                    if isinstance(ap, list) and ap: s.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): s.ask = float(ap)
                except: pass

            s.ts = time.time()
            self.stocks[code] = s
            
        if self.on_tick_callback and code:
            self.on_tick_callback(code)

    def update_future(self, tick: Any):
        code = ""
        with self._lock:
            code = getattr(tick, "code", "")
            if not code: return
            f = self.futures.get(code, MarketSnapshot(code))
            
            # tick price
            if hasattr(tick, "close"): f.price = float(tick.close)
            elif hasattr(tick, "price"): f.price = float(tick.price)
            
            # bid/ask (best1) parsing
            if hasattr(tick, "bid_price") and hasattr(tick, "ask_price"):
                try:
                    bp = tick.bid_price
                    ap = tick.ask_price
                    if isinstance(bp, list) and bp: f.bid = float(bp[0])
                    elif isinstance(bp, (float, int)): f.bid = float(bp)
                        
                    if isinstance(ap, list) and ap: f.ask = float(ap[0])
                    elif isinstance(ap, (float, int)): f.ask = float(ap)
                except: pass

            f.ts = time.time()
            self.futures[code] = f
            
        if self.on_tick_callback and code:
            self.on_tick_callback(code)



    def get_stock(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.stocks.get(code)
    def get_future(self, code: str) -> Optional[MarketSnapshot]:
        with self._lock:
            return self.futures.get(code)

class StrategyEngine:
    def __init__(self, market_data: MarketData, check_holdings_cb: Optional[Callable[[str], bool]] = None):
        self.md = market_data
        self.check_holdings_cb = check_holdings_cb
        self.stats: Dict[Tuple[str, str], StrategyState] = {}
        
        # Parameters
        self.Z_ENTRY = 2.0
        self.Z_EXIT = 0.5
        self.MIN_STD = 0.1 # Floor to prevent division by zero or huge Z on flat markets
        
    def _get_stats(self, stock_code: str, future_code: str) -> StrategyState:
        key = (stock_code, future_code)
        if key not in self.stats:
            self.stats[key] = StrategyState(half_life_sec=300) # 5-min half life
        return self.stats[key]
    
    def on_tick(self, stock_code: str, future_code: str) -> Optional[TradeIntent]:
        stk = self.md.get_stock(stock_code)
        fut = self.md.get_future(future_code)
        
        # Helper for mid price
        def _get_px(s):
            if not s: return 0.0
            if s.bid > 0 and s.ask > 0: return (s.bid + s.ask) / 2
            return s.price

        stk_px = _get_px(stk)
        fut_px = _get_px(fut)
        
        if stk_px <= 0 or fut_px <= 0:
            return None
            
        # 1. Calculate Spread (Mid Price if available)
        stk_px = stk.price
        if stk.bid > 0 and stk.ask > 0:
            stk_px = (stk.bid + stk.ask) / 2
            
        fut_px = fut.price
        if fut.bid > 0 and fut.ask > 0:
            fut_px = (fut.bid + fut.ask) / 2
            
        spread = fut_px - stk_px
        
        # 2. Update Stats
        stats = self._get_stats(stock_code, future_code)
        stats.update(spread)
        
        if stats.samples < 10: # Warmup
            return None
            
        # 3. Calculate Z-Score
        std = max(stats.std, self.MIN_STD)
        z_score = (spread - stats.mean) / std
        
        msg = f"[Strategy] {stock_code} Spread={spread:.2f} Z={z_score:.2f} (µ={stats.mean:.2f} σ={std:.2f})"
        
        # Optimize Logging (Fix A3-v3: Smart Filtering)
        # 1. Entry Signal (Z > Entry):
        #    - If NOT held: Important (New Opportunity) -> Newline
        #    - If Held: Spam (Already in) -> In-Place
        # 2. Close Signal (Z < Exit):
        #    - If Held: Actionable (Exit now) -> Newline
        #    - If NOT held: Noise (Market reverting) -> In-Place
        
        is_entry = z_score > self.Z_ENTRY
        is_close_signal = abs(z_score) < self.Z_EXIT
        
        has_position = False
        if self.check_holdings_cb:
            has_position = self.check_holdings_cb(stock_code)
            
        should_print_newline = False
        
        if is_entry:
             # Only print if we DON'T have it yet (Opportunity)
             if not has_position:
                 should_print_newline = True
        elif is_close_signal:
             # Only print if we DO have it (Action needed)
             if has_position:
                 should_print_newline = True
                 
        if should_print_newline:
              print(msg) 
        # Removed "In-Place" print to stop spamming and threading contention
        # Status will be shown by Main Loop
        pass
        
        # 4. Generate Signals
        # Entry: Future is Expensive (High Spread) -> Short Future / Long Stock
        if z_score > self.Z_ENTRY:
            return TradeIntent(
                type=SignalType.OPEN,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"Z={z_score:.2f} > {self.Z_ENTRY}"
            )
            
        # Exit: Spread normalizes (Low Z)
        # Note: In vb01, 'CLOSE' intent usually implies checking if we HAVE a position.
        # But Strategy is pure, so it just says "Market is good for Closing".
        # TxManager decides if there's anything to close.
        elif abs(z_score) < self.Z_EXIT:
            return TradeIntent(
                type=SignalType.CLOSE,
                stock_code=stock_code,
                future_code=future_code,
                qty=1,
                details=f"|Z|={abs(z_score):.2f} < {self.Z_EXIT}"
            )
            
        return None

# --- Execution Engine (The Gateway) ---

class ExecutionEngine:
    """
    Handles connection to Shioaji, Authentication, and Raw Order Placement.
    Does NOT manage state. Just executes commands.
    """
    def __init__(self):
        print(f"[Execution] CWD: {os.getcwd()}")
        load_dotenv()
        
        # Init API
        # Use Simulation=True by default unless overridden
        self.api = sj.Shioaji(simulation=True)
        
        # Load Credentials (va3 style)
        self.person_id = os.getenv("Sinopack_PERSON_ID") 
        self.password = os.getenv("Sinopack_PASSWORD")
        self.ca_api_key = os.getenv("Sinopack_CA_API_KEY")
        self.ca_secret_key = os.getenv("Sinopack_CA_SECRET_KEY")
        self.ca_path = os.getenv("Sinopack_CA_PATH")
        self.ca_password = os.getenv("Sinopack_CA_PASSWORD")
        
        # Debug
        k_len = len(self.ca_api_key) if self.ca_api_key else 0
        s_len = len(self.ca_secret_key) if self.ca_secret_key else 0
        print(f"[Execution] Keys loaded. API_KEY len={k_len}, SECRET_KEY len={s_len}, PERSON_ID={self.person_id}")

        self.stock_account = None
        self.futopt_account = None
        
        # Callback for TxManager to hook into
        self.on_order_callback = None 
        
        # Track recent orders for 'o' command
        self.recent_orders = []
        self.seqno_to_trade = {} # List[Dict] 

    def get_contract(self, code: str, security_type: str = "Stock"):
        if security_type == "Stock":
             # Stocks is a dict-like map, but sometimes nested?
             # Standard Shioaji: api.Contracts.Stocks["2330"] works.
             return self.api.Contracts.Stocks.get(code)
        elif security_type == "Future":
             # Futures are category-based list of lists/tuples
             for cat in self.api.Contracts.Futures:
                 try: iter(cat)
                 except: continue
                 for c in cat:
                     if isinstance(c, tuple): c = c[1]
                     if getattr(c, "code", "") == code:
                         return c
        return None

    def login(self):
        print("[Execution] Connecting to Shioaji API...")
        if not self.ca_api_key or not self.ca_secret_key:
            print("[Execution] Fatal: Missing API Key/Secret.")
            return False

        try:
            # va3 login style
            self.api.login(
                api_key=self.ca_api_key, 
                secret_key=self.ca_secret_key,
                contracts_cb=lambda x: print(f"[Execution] Contracts loaded: {x}"),
                subscribe_trade=True
            )
            print("[Execution] Login success (Session Up). Waiting for contracts...")
            # Simple wait for contract load (va3 waits 5s)
            time.sleep(5.0)
        except Exception as e:
            print(f"[Execution] Login failed: {e}")
            return False

        # Activate CA (if needed for trading, though simulation usually doesn't need it but good to have)
        # Activate CA (Skipped for Simulation Stability - Fix A2)
        # if self.ca_path and self.ca_password and self.person_id:
        #     try:
        #         self.api.activate_ca(ca_path=self.ca_path, ca_passwd=self.ca_password, person_id=self.person_id)
        #         print("[Execution] CA Activated.")
        #     except Exception as e:
        #         print(f"[Execution] CA Activation failed: {e}")
        print("[Execution] CA Activation SKIPPED (Simulation Mode Stability).")
        
        # Set Accounts
        self.stock_account = self.api.stock_account
        self.futopt_account = self.api.futopt_account
        
        if not self.stock_account or not self.futopt_account:
            print("[Execution] Warning: Accounts not retrieved (Sim mode maybe?).")
            # In sim mode, sometimes account objects are empty or different.
            # But usually they exist.
        else:
            print(f"[Execution] Stock Account: {self.stock_account.account_id}")
            print(f"[Execution] Future Account: {self.futopt_account.account_id}")
        
        # Hook global callbacks
        self.api.set_order_callback(self._wrap_callback)
        return True

    def _wrap_callback(self, *args, **kwargs):
        """
        Routes Shioaji callbacks (supports both (topic, msg) and (OrderState) signatures).
        """
        if not self.on_order_callback:
            return

        # Case A: (topic, msg)
        if len(args) == 2 and isinstance(args[0], str):
            topic, msg = args
            if topic != "OrderState":
                return
            data = msg or {}

        # Case B: (state,) or similar object
        elif len(args) >= 1:
            topic = "OrderState" # Default for direct object callbacks
            state = args[0]
            # Convert to dict
            if isinstance(state, dict):
                data = state
            elif hasattr(state, "to_dict"):
                data = state.to_dict()
            else:
                data = getattr(state, "__dict__", {}) or {}
        else:
            return
            
        # Parse fields
        if topic == "OrderState":
             # Debug execution events
             # print(f"[CB DEBUG] {topic} {data}") 
             pass
             
        op = data.get("operation", {}) or {}
        order = data.get("order", {}) or {}
        status = data.get("status", {}) or {}

        op_code = op.get("op_code", "")
        op_msg = op.get("op_msg", "")

        seqno = order.get("seqno", "") or order.get("id", "") or order.get("ordno", "")
        oid = order.get("id", "") or order.get("ordno", "")
        
        # Log all OrderState events to console to debug missing fills
        if topic == "OrderState":
             print(f"[CB] Seq={seqno} OID={oid} Op={op_code} Msg={op_msg} Stat={status.get('status')}")

        self.on_order_callback(oid, seqno, op_code, op_msg, status)

    def place_stock_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        """
        Returns Order ID (seqno) if successful, None otherwise.
        """
        try:
            # Fix: Use helper
            contract = resolve_stock_contract(self.api, code)
            if not contract:
                print(f"[Execution] Stock contract not found: {code}")
                return None

            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.StockPriceType.LMT if price_type == "LMT" else sj_constant.StockPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC
            
            # Fix 2B: MKT price should be 0
            if pt == sj_constant.StockPriceType.MKT:
                price = 0.0

            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.stock_account
                )
            )
            
            # Track for cancellation
            self.seqno_to_trade[trade.order.seqno] = trade
            
            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Stock")
            
            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Stock Order Failed: {e}")
            return None

    def place_future_order(self, code: str, action: str, price: float, qty: int, price_type: str = "LMT", order_type: str = "ROD") -> Optional[str]:
        try:
            # Need to find contract carefully
            # Need to find contract carefully
            contract = resolve_future_contract(self.api, code)
            if not contract:
                print(f"[Execution] Future contract not found: {code}")
                return None

            act = sj_constant.Action.Buy if action == "Buy" else sj_constant.Action.Sell
            pt = sj_constant.FuturesPriceType.LMT if price_type == "LMT" else sj_constant.FuturesPriceType.MKT
            ot = sj_constant.OrderType.ROD if order_type == "ROD" else sj_constant.OrderType.IOC
            
            # Fix 2B: MKT price should be 0
            if pt == sj_constant.FuturesPriceType.MKT:
                price = 0.0

            trade = self.api.place_order(
                contract=contract,
                order=self.api.Order(
                    price=price,
                    quantity=qty,
                    action=act,
                    price_type=pt,
                    order_type=ot,
                    account=self.futopt_account
                )
            )
            
            self.seqno_to_trade[trade.order.seqno] = trade
            
            # Track
            self._track_order(trade.order.seqno, code, action, price, qty, "Future")
            
            return trade.order.seqno
        except Exception as e:
            print(f"[Execution] Future Order Failed: {e}")
            return None

    def _resolve_future_contract(self, code: str):
        # Simplistic lookup, assuming standard code
        for cat in self.api.Contracts.Futures:
            try: iter(cat)
            except: continue
            for c in cat:
                if isinstance(c, tuple): c = c[1]
                if c.code == code:
                    return c
        return None

    def _track_order(self, seqno, code, action, price, qty, product):
        ts = time.strftime("%H:%M:%S")
        self.recent_orders.append({
            "time": ts,
            "seqno": seqno,
            "code": code,
            "action": action,
            "price": price,
            "qty": qty,
            "product": product,
            "status": "Submitted"
        })
        # Keep last 50
        if len(self.recent_orders) > 50:
            self.recent_orders.pop(0)

    def dump_orders(self) -> str:
        if not self.recent_orders:
             return "No orders yet."
        lines = ["\n=== RECENT ORDERS ==="]
        for o in self.recent_orders:
            lines.append(f"{o['time']} [{o['product']}] {o['action']} {o['code']} Q={o['qty']} P={o['price']} Seq={o['seqno']} St={o['status']}")
        return "\n".join(lines)

    def cancel_all_orders(self):
        """Cancel all pending orders in both accounts"""
        print("[Execution] Cancelling all open orders...")
        try:
            self.api.update_status()
            for trade in self.api.list_trades():
                if trade.status.status in ("PreSubmitted", "Submitted", "PartFilled"):
                    self.api.cancel_order(trade)
                    print(f"  Cancelled: {trade.contract.code} {trade.order.action}")
        except Exception as e:
            print(f"[Execution] Cancel failed: {e}")

    def cancel_order_by_seqno(self, seqno: str):
        """Cancel order using stored trade object."""
        try:
            trade = self.seqno_to_trade.get(seqno)
            if trade:
                self.api.cancel_order(trade)
                print(f"[Execution] Cancelled order {seqno}")
            else:
                print(f"[Execution] Cannot cancel {seqno}: Trade object not found.")
        except Exception as e:
            print(f"[Execution] Cancel failed for {seqno}: {e}")

    def get_order_status(self, seqno: str) -> Optional[Dict]:
        """Fetch latest status for a specific order by seqno via polling."""
        try:
            # Refresh both accounts to be sure
            if self.stock_account: self.api.update_status(self.stock_account)
            if self.futopt_account: self.api.update_status(self.futopt_account)
            
            trades = self.api.list_trades()
            
            # DEBUG: Print trade count if we are polling (means we are waiting for something)
            # print(f"[Debug] Polling seqno={seqno}. Total Trades Found: {len(trades)}")
            
            for trade in trades:
                if trade.order.seqno == seqno:
                    # Convert to our standard format
                    status_str = trade.status.status # e.g. "Filled", "Cancelled"
                    deal_quantity = trade.status.deal_quantity
                    # print(f"  -> Found: {status_str} Qty={deal_quantity}")
                    return {
                        "status": status_str,
                        "deal_quantity": deal_quantity,
                        "ordno": trade.order.ordno,
                        "id": trade.order.id
                    }
        except Exception as e:
            # print(f"[Execution] poll status failed: {e}")
            pass
        return None



# --- Core Transaction Classes ---

    def get_all_positions(self) -> Dict[str, int]:
        """Returns map of code -> net signed quantity"""
        pos_map = {}
        try:
             # Stocks
             if self.stock_account:
                 for p in self.api.list_positions(self.stock_account):
                     pos_map[p.code] = int(p.quantity)
             # Futures
             if self.futopt_account:
                 for p in self.api.list_positions(self.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj_constant.Action.Buy else -qty
                     pos_map[p.code] = net
        except: pass
        return pos_map

    def dump_positions(self) -> str:
        lines = ["\n=== POSITIONS ==="]
        try:
             # Force update
             if self.stock_account: self.api.update_status(self.stock_account)
             if self.futopt_account: self.api.update_status(self.futopt_account)
             
             # Stock
             if self.stock_account:
                 pos = self.api.list_positions(self.stock_account)
                 lines.append(f"Stocks ({len(pos)}):")
                 for p in pos:
                     # quantity is int. price is float.
                     lines.append(f"  {p.code} Qty={int(p.quantity)} avgP={p.price}")
            
             # Future
             if self.futopt_account:
                 pos = self.api.list_positions(self.futopt_account)
                 lines.append(f"Futures ({len(pos)}):")
                 for p in pos:
                     code = getattr(p, "code", "Unknown")
                     qty = getattr(p, "quantity", 0)
                     price = getattr(p, "price", 0)
                     # direction = getattr(p, "direction", "")
                     lines.append(f"  {code} Qty={int(qty)} avgP={price}")

        except Exception as e:
             lines.append(f"Error: {e}")
        return "\n".join(lines)

# --- Core Transaction Classes ---

class BaseTransaction:
    def __init__(self, intent: TradeIntent, tx_mgr):
        self.tx_id = str(uuid.uuid4())[:8]
        self.intent = intent
        self.mgr = tx_mgr
        self.state = TransactionState.INIT
        self.created_at = time.time()
        self.updated_at = time.time()
        self.state_enter_ts = time.time()
        
        self.stock_order = OrderStub()
        self.future_order = OrderStub()
        
        self.last_poll_ts = 0
        
        self.log(f"Transaction Created: {intent}")

    def log(self, msg: str):
        ts = time.strftime("%H:%M:%S")
        print(f"[{ts}] [Tx-{self.tx_id}] {msg}")

    def set_state(self, new_state: TransactionState, msg: str = ""):
        self.state = new_state
        self.state_enter_ts = time.time()
        if msg:
            self.log(msg)

    def update(self):
        self.updated_at = time.time()
        if self.state == TransactionState.INIT:
            self._step_init()
        elif self.state == TransactionState.LEG1_SUBMITTED:
            self._check_leg1_polling() # Polling Failsafe
            self._check_leg1_timeout()
        elif self.state == TransactionState.LEG1_FILLED:
            self._step_place_leg2()
        elif self.state == TransactionState.LEG2_SUBMITTED:
            self._check_leg2_polling() # Polling Failsafe
            self._check_leg2_timeout()

    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        # Match order by seqno
        # Leg 1
        if seqno == self.stock_order.seqno:
            self.log(f"Leg 1 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                # Check fill
                delta = _apply_fill(self.stock_order, status_data)
                if delta > 0:
                    self.log(f"Leg 1 Partial Fill: +{delta} (Total: {self.stock_order.filled_qty})")
                    if self.stock_order.filled_qty >= self.intent.qty:
                        self.set_state(TransactionState.LEG1_FILLED, "Leg 1 Fully Filled.")
                        self.stock_order.status = "Filled"
            else:
                 self.stock_order.status = "Failed"
                 self.stock_order.error_msg = msg
                 self.set_state(TransactionState.FAILED, f"Leg 1 FAILED: {msg}")

        # Leg 2
        elif seqno == self.future_order.seqno:
            self.log(f"Leg 2 Update: Code={op_code} Msg={msg}")
            if op_code == "00":
                delta = _apply_fill(self.future_order, status_data)
                if delta > 0:
                    self.log(f"Leg 2 Partial Fill: +{delta} (Total: {self.future_order.filled_qty})")
                    if self.future_order.filled_qty >= self.intent.qty:
                        self.set_state(TransactionState.COMPLETED, "Transaction COMPLETED.")
                        self.future_order.status = "Filled"
            else:
                 self.future_order.status = "Failed"
                 self.future_order.error_msg = msg
                 self.set_state(TransactionState.FAILED, f"Leg 2 FAILED: {msg}")

    # --- Step Implementations ---

    def _step_init(self):
        # 0. Liquidity Check (Slippage Protection)
        snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
        if not snapshot: # No data yet
            self.log("No market data for Leg 1. Waiting...")
            return 
            
        # Check Ask Volume (Approximated by volume of last tick if no bidask? 
        # Ideally we need bidask snapshot. MarketData updates 'volume' from tick current volume, which is not ask volume.
        # But 'update_stock' receives 'bidask' object if available.
        # Let's assume MarketSnapshot has 'ask_volume' or we fetch from bidask.
        # For now, simplistic: Check if price exists.
        
        # Real Slippage Protection: Use Limit Price = Ask * 1.01 (1% buffer)
        # instead of Market Order.
        if snapshot.price <= 0:
            return 
            
        limit_price = snapshot.price * 1.01 # Buy 1% higher to ensure fill but capped slippage
        
        self.log(f"Placing Leg 1 (Stock {self.intent.stock_code}) Market Order...")
        
        action = "Buy" if self.intent.type == SignalType.OPEN else "Sell"
        
        seqno = self.mgr.execution.place_stock_order(
            self.intent.stock_code, action, 0, self.intent.qty, "MKT", "ROD"
        )
        
        if seqno:
            self.stock_order.seqno = seqno
            self.stock_order.status = "Submitted"
            self.state = TransactionState.LEG1_SUBMITTED
            self.log(f"Leg 1 Submitted SeqNo: {seqno}")
            self.log(f"Leg 1 Submitted SeqNo: {seqno}")
        else:
            self.set_state(TransactionState.FAILED, "Leg 1 Submission Failed")

    def _check_leg1_timeout(self):
        if time.time() - self.state_enter_ts > 90: # Increased from 30s to 90s for Sim Latency
            self.log("Leg 1 Timeout. Cancelling...")
            self.mgr.execution.cancel_order_by_seqno(self.stock_order.seqno)
            self.set_state(TransactionState.FAILED, "Leg 1 Timeout & Cancelled")

    def _step_place_leg2(self):
        # Dynamic Hedge: Hedge only what was filled
        filled_qty = self.stock_order.filled_qty
        if filled_qty <= 0:
            self.log("Leg 1 Filled Qty is 0? Strange.")
            self.state = TransactionState.FAILED
            return

        # Ratio Logic: Assuming 1:1 for simplicity or predefined ratio
        # In real TAIEX: 2 Stocks (2000 shares) : 1 Future (2000 shares) usually.
        # Let's assume self.intent.qty is in "Lots" (1 Lot = 1 Future + N Stocks)
        # But stock_order.filled_qty is raw shares or lots? Shioaji uses Lots (sheets).
        
        # If I bought filled_qty (sheets), how many futures?
        # Future Qty = filled_qty / 2 (Round?)
        # For safety/demo: hedge_qty = filled_qty (assuming 1:1)
        hedge_qty = filled_qty 
        
        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Qty={hedge_qty}...")
        action = "Sell" if self.intent.type == SignalType.OPEN else "Buy"
        
        # Slippage Protection for Leg 2:
        # We MUST fill this to hedge. Market order is safer for delta neutral, 
        # but Limit BID-1% is better protection.
        # Since we are SELLING future, we want to sell at Bid. 
        # Aggressive: Sell at Bid * 0.99
        snapshot = self.mgr.market_data.get_future(self.intent.future_code)
        # base_price = snapshot.price if snapshot and snapshot.price > 0 else 1000
        # limit_price = base_price * 0.99
        
        self.log(f"Placing Leg 2 (Future {self.intent.future_code}) Market Order...")

        seqno = self.mgr.execution.place_future_order(
            self.intent.future_code, action, 0, hedge_qty, "MKT", "IOC" # IOC to avoid hanging
        )
        
        if seqno:
            self.future_order.seqno = seqno
            self.future_order.status = "Submitted"
            self.set_state(TransactionState.LEG2_SUBMITTED)
            self.log(f"Leg 2 Submitted SeqNo: {seqno}")
        else:
            self.set_state(TransactionState.FAILED, "Leg 2 Submission Failed")

    def _check_leg2_timeout(self):
        if time.time() - self.state_enter_ts > 20: # Longer timeout for leg 2
            self.log("Leg 2 Timeout. Cancelling...")
            self.mgr.execution.cancel_order_by_seqno(self.future_order.seqno)
            self.set_state(TransactionState.FAILED, "Leg 2 Timeout & Cancelled")

    # --- Polling Failsafe ---
    def _check_leg1_polling(self):
        # Poll every 2 seconds
        if time.time() - self.last_poll_ts < 2.0: return
        self.last_poll_ts = time.time()
        
        # print(f"[Tx-{self.tx_id}] Polling Leg 1 status...") # Debug
        status = self.mgr.execution.get_order_status(self.stock_order.seqno)
        if status:
            s_str = status.get("status")
            qty = status.get("deal_quantity", 0)
            # print(f"[Tx-{self.tx_id}] Poll Result: {s_str} Qty={qty}") # Debug
            
            if s_str == "Filled" or qty >= self.intent.qty:
                self.log(f"[Polling] Detected Leg 1 Fill! Qty={qty}")
                # Simulate Callback
                self.on_order_update(self.stock_order.seqno, "00", "Polled Fill", status)
            elif s_str == "Cancelled":
                self.log(f"[Polling] Detected Leg 1 Cancel.")
                self.set_state(TransactionState.FAILED, "Leg 1 Cancelled")
        else:
             # Fallback: if list_trades fails, check list_positions?
             # Only if we suspect a fill but get no trade record.
             pass

    def _check_leg2_polling(self):
        if time.time() - self.last_poll_ts < 2.0: return
        self.last_poll_ts = time.time()
        
        status = self.mgr.execution.get_order_status(self.future_order.seqno)
        if status:
            s_str = status.get("status")
            qty = status.get("deal_quantity", 0)
            if s_str == "Filled" or qty >= self.intent.qty:
                self.log(f"[Polling] Detected Leg 2 Fill! Qty={qty}")
                self.on_order_update(self.future_order.seqno, "00", "Polled Fill", status)
            # self.mgr.execution.cancel_order(self.future_order.seqno)
            self.set_state(TransactionState.FAILED)

class OpenArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Open:
    1. Buy Stock
    2. Sell Future
    """
    pass

class CloseArbitrageTransaction(BaseTransaction):
    """
    Arbitrage Exit:
    1. Buy Future (Close Short) - Priority to remove unlimited risk
    2. Sell Stock (Close Long)
    """
    def update(self):
        # 1. INIT -> Buy Future
        if self.state == TransactionState.INIT:
            # Liquidity Check (Future Ask)
            snapshot = self.mgr.market_data.get_future(self.intent.future_code)
            if not snapshot or snapshot.price <= 0:
                 self.log("No Future Price. Waiting...")
                 return
            
            # Limit Price = Ask * 1.01 (Buy aggressive)
            # limit_price = snapshot.price * 1.01 
            self.log(f"Closing: Buying Future {self.intent.future_code} Market Order...")
            
            seqno = self.mgr.execution.place_future_order(
                self.intent.future_code, "Buy", 0, self.intent.qty, "MKT", "IOC" 
            )
            
            if seqno:
                self.future_order.seqno = seqno
                self.future_order.status = "Submitted"
                self.set_state(TransactionState.LEG1_SUBMITTED)
            else:
                 self.set_state(TransactionState.FAILED, "Future Buy Failed")

        # 1.5 Timeout Check for Future Buy
        elif self.state == TransactionState.LEG1_SUBMITTED:
             if time.time() - self.state_enter_ts > 10:
                  self.log("Close Leg 1 (Future) Timeout. Cancelling...")
                  self.set_state(TransactionState.FAILED)

        # 2. LEG1_FILLED -> Sell Stock
        elif self.state == TransactionState.LEG1_FILLED:
            filled_qty = self.future_order.filled_qty
            # Hedge Ratio: 1 Future -> 1 Lot Stock (Simplicity)
            hedge_qty = filled_qty
            
            self.log(f"Closing: Selling Stock {self.intent.stock_code} Qty={hedge_qty}...")
            
            # Sell Stock Aggressive (Bid * 0.99)
            snapshot = self.mgr.market_data.get_stock(self.intent.stock_code)
            # base_price = snapshot.price if snapshot and snapshot.price > 0 else 1000
            # limit_price = base_price * 0.99
            
            self.log(f"Closing: Selling Stock {self.intent.stock_code} Market Order...")
            
            seqno = self.mgr.execution.place_stock_order(
                self.intent.stock_code, "Sell", 0, hedge_qty, "MKT", "ROD"
            )
            
            if seqno:
                self.stock_order.seqno = seqno
                self.set_state(TransactionState.LEG2_SUBMITTED)
            else:
                self.set_state(TransactionState.FAILED, "Stock Sell Failed")
        
        elif self.state == TransactionState.LEG2_FILLED:
            self.set_state(TransactionState.COMPLETED, "Arbitrage Close Complete")

    # CloseArbitrageTransaction overrides update and on_order_update completely
    def on_order_update(self, seqno: str, op_code: str, msg: str, status_data: Dict):
        # Leg1 = Future buy, Leg2 = Stock sell
        # Do NOT call super() here to avoid logic conflict
        
        if seqno == self.future_order.seqno:
            self.log(f"[Close] Future Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Future leg failed: {msg}")
                return
            
            delta = _apply_fill(self.future_order, status_data)
            if delta > 0:
                self.log(f"[Close] Future fill +{delta} (total {self.future_order.filled_qty})")
            
            if self.future_order.filled_qty >= self.intent.qty:
                self.set_state(TransactionState.LEG1_FILLED, "Future leg filled")

        elif seqno == self.stock_order.seqno:
            self.log(f"[Close] Stock Update: {op_code} {msg}")
            if op_code != "00":
                self.set_state(TransactionState.FAILED, f"Stock leg failed: {msg}")
                return
            
            delta = _apply_fill(self.stock_order, status_data)
            if delta > 0:
                self.log(f"[Close] Stock fill +{delta} (total {self.stock_order.filled_qty})")
            
            # Fix: Compare against Future leg filled qty (Hedge target), not intent
            tgt = self.future_order.filled_qty
            if self.stock_order.filled_qty >= tgt and tgt > 0:
                self.set_state(TransactionState.LEG2_FILLED, "Stock leg filled (Hedge Complete).")

# --- Pair Discovery ---

class PairDiscovery:
    def __init__(self, api: sj.Shioaji):
        self.api = api
        
    def _load_local_history(self) -> Tuple[set, set]:
        """
        Reads local order_history.jsonl to find recently traded codes.
        Returns (local_stocks, local_futures)
        """
        l_stocks = set()
        l_futures = set()
        path = "order_history.jsonl"
        if not os.path.exists(path):
            return l_stocks, l_futures
            
        print(f"[Discovery] Reading local history from {path}...")
        try:
            with open(path, "r", encoding="utf-8") as f:
                # Read last 100 lines is usually enough, but let's read all simply
                lines = f.readlines()
                # Process in reverse to get latest
                for line in reversed(lines):
                    try:
                        rec = json.loads(line)
                        f_code = rec.get("fut_code")
                        s_code = rec.get("stock_code")
                        if f_code: l_futures.add(f_code)
                        if s_code: l_stocks.add(s_code)
                    except: pass
            print(f"[Discovery] Recovered from history - Stocks: {len(l_stocks)}, Futures: {len(l_futures)}")
            # Debug: print sample
            if l_futures: print(f"[Discovery] History Futures Sample: {list(l_futures)[:5]}")
        except Exception as e:
            print(f"[Discovery] History load failed: {e}")
            
        return l_stocks, l_futures

    def scan(self, limit: int = 5) -> List[Tuple[str, str]]:
        """
        Scans for valid Stock-Future pairs. 
        Priority:
        1. Pairs where we hold positions (Stock or Future).
        2. Popular pairs (e.g. 2330) if space allows.
        """
        found = [] # List[(stock_code, future_code)]
        held_stocks = set()
        held_futures = set()
        
        print("[Discovery] Syncing positions (wait 3s)...")
        # Retry logic for update_status (Fix A1)
        for attempt in range(3):
            try:
                if hasattr(self.api, "update_status"):
                    try: self.api.update_status(self.api.stock_account)
                    except: pass
                    try: self.api.update_status(self.api.futopt_account) 
                    except: pass
                # Success (or no exception from update_status itself, though it returns dict often)
                time.sleep(3.0) 
                break
            except Exception as e:
                print(f"[Discovery] Sync attempt {attempt+1} failed: {e}")
                time.sleep(2.0)


        # Load Local History to supplement API
        h_stocks, h_futures = self._load_local_history()
        
        print("[Discovery] Scanning positions first...")
        
        # 1. Get Held Positions (API + History)
        # 1. Get Held Positions (API + History) with Retry
        for attempt in range(3):
            try:
                held_stocks.clear()
                held_futures.clear()
                
                if self.api.stock_account:
                    pos = self.api.list_positions(self.api.stock_account)
                    for p in pos:
                        code = getattr(p, "code", "")
                        if code: held_stocks.add(code)
                
                if self.api.futopt_account:
                    pos = self.api.list_positions(self.api.futopt_account)
                    for p in pos:
                        code = getattr(p, "code", "")
                        if code: held_futures.add(code)
                
                # If successful
                break
            except Exception as e:
                print(f"[Discovery] API Position scan attempt {attempt+1} failed: {e}")
                time.sleep(2.0)
                if attempt == 2:
                    print("[Discovery] Giving up on Position Scan. Assuming 0 positions.")

        # Merging history causes Zombie pairs to block new ones.
        # We only want to monitor what we ACTUALLY hold right now.
        # held_stocks.update(h_stocks)
        # held_futures.update(h_futures)
        
        print(f"[Discovery] Active Held Stocks: {held_stocks}")
        print(f"[Discovery] Active Held Futures: {held_futures}")

        # 2. Map Futures to Stocks
        # 2. Map Futures to Stocks & Volume Scan
        print("[Discovery] Scanning contracts for candidates...")
        
        # A) Find all stocks that HAVE a future
        candidates_map = {} # stock_code -> future_contract
        try:
            for category in self.api.Contracts.Futures:
                try: iter(category)
                except: continue
                for contract in category:
                    if isinstance(contract, tuple): contract = contract[1]
                    if not contract: continue
                    f_code = getattr(contract, "code", "")
                    u_code = getattr(contract, "underlying_code", "") 
                    
                    if not u_code: continue
                    # Only map if we haven't seen this stock, OR if this future is 'better' (e.g. Standard vs Mini)
                    # For simplicity, we take the first valid one we find, or maybe prefer R1/Specific if implementing logic.
                    # VB01 Simplicity: Store first valid future.
                    if u_code not in candidates_map:
                        candidates_map[u_code] = contract

        except Exception as e:
            print(f"[Discovery] Contract map failed: {e}")

        # B) Add Held Pairs to 'found' immediately (Priority 1)
        for s_code in held_stocks:
            if s_code in candidates_map:
                f_c = candidates_map[s_code]
                pair = (s_code, f_c.code)
                if pair not in found:
                    found.append(pair)
        
        # C) Volume Scan for remaining slots (Priority 2)
        remaining = limit - len(found)
        if remaining > 0:
            print(f"[Discovery] Need {remaining} more pairs. Fetching volumes for {len(candidates_map)} candidates...")
            
            # Get objects for snapshots
            stk_contracts = []
            valid_u_codes = []
            none_count = 0
            
            for u_code in candidates_map.keys():
                try:
                    c = self.api.Contracts.Stocks[u_code]
                    if c is None:
                        # Evidence: Log the problematic code
                        # print(f"[Debug] Stock {u_code} returned None object")
                        none_count += 1
                        continue
                    stk_contracts.append(c)
                    valid_u_codes.append(u_code)
                except: pass
            
            if none_count > 0:
                print(f"[Discovery] Filtered out {none_count} None/Invalid contracts to prevent crash.")

            # Batch Snapshot (Chunked)
            vol_map = {} # u_code -> volume
            
            # Simulation Fallback Weights (Top 30 Taiwan Stock Weights)
            # Used when API returns 0 volume in Sim
            blue_chips = {
                '2330': 100000, '2317': 90000, '2454': 85000, '2303': 80000, '2881': 75000,
                '1301': 70000, '1303': 69000, '2882': 68000, '2002': 67000, '1216': 66000,
                '2412': 65000, '2308': 64000, '2891': 63000, '3231': 62000, '2382': 61000,
                '2886': 60000, '2884': 59000, '2357': 58000, '1101': 57000, '2892': 56000,
                '5880': 55000, '2880': 54000, '3008': 53000, '2603': 52000, '3711': 51000,
                '2885': 50000, '2207': 49000, '3045': 48000, '5876': 47000, '2301': 46000
            }

            # PRE-FILL: Ensure we have data even if API crashes
            for bc_code, bc_vol in blue_chips.items():
                if bc_code in candidates_map:
                     vol_map[bc_code] = bc_vol

            chunk_size = 200
            for i in range(0, len(stk_contracts), chunk_size):
                chunk = stk_contracts[i:i+chunk_size]
                try:
                    snaps = self.api.snapshots(chunk) # Corrected from snapshot -> snapshots
                    for s in snaps:
                        price = float(getattr(s, 'close', 0) or getattr(s, 'reference_price', 0) or 0)
                        
                        # Price Filter: Exclude if > 500
                        if price > 500:
                            # print(f"[Discovery] Filtered outdated pair {s.code} (Price={price} > 500)")
                            vol_map[s.code] = 0
                            continue

                        v = int(getattr(s, 'total_volume', 0) or 0)
                        # Fallback for Sim
                        if v == 0 and s.code in blue_chips:
                             v = blue_chips[s.code]
                        vol_map[s.code] = v
                except Exception as e:
                    print(f"[Discovery] Snapshot chunk failed: {e}")
            
            # Sort by Volume Desc
            sorted_candidates = sorted(valid_u_codes, key=lambda x: vol_map.get(x, 0), reverse=True)
            
            # Pick Top N
            for u_code in sorted_candidates:
                if len(found) >= limit: break
                
                # Check if already added via holdings
                is_added = any(p[0] == u_code for p in found)
                if is_added: continue
                
                f_c = candidates_map[u_code]
                found.append((u_code, f_c.code))
                print(f"[Discovery] Added Top Vol Pair: {u_code} (Vol={vol_map.get(u_code,0)})")

            if not found:
                # If no positions found, try 2330
                if "2330" in self.api.Contracts.Stocks:
                    # Find 2330 Future
                    for category in self.api.Contracts.Futures:
                        try: iter(category)
                        except: continue
                        for c in category:
                            if isinstance(c, tuple): c = c[1]
                            if getattr(c, "underlying_code", "") == "2330":
                                found.append(("2330", c.code))
                                break
                        if found: break
            
            # Limit
            final_list = found[:limit]
            print(f"[Discovery] Final Pairs: {final_list}")
            return final_list
            


import sys

# --- Transaction Manager ---

class TransactionManager:
    def __init__(self):
        self._lock = threading.Lock() # Protects active_transactions & cooldowns
        self.market_data = MarketData(on_tick_callback=self._on_market_tick)
        self.execution = ExecutionEngine()
        self.held_positions: set[str] = set() # Cache of stock codes we currently hold (or are trading)
        
        # Helper to check if we hold a stock (for Strategy Logging)
        # Note: StrategyEngine calls this to decide if log should be preserved.
        def _check_holdings(stock_code):
            # True if we have an active transaction OR we physically hold it
            return (stock_code in self.active_transactions) or (stock_code in self.held_positions)
            
        self.strategy = StrategyEngine(self.market_data, check_holdings_cb=_check_holdings)
        
        self.active_transactions: Dict[str, BaseTransaction] = {}
        self.completed_transactions: List[BaseTransaction] = []
        self.cooldowns: Dict[str, float] = {} # code -> expiry timestamp
        
        self.monitored_pairs: List[Tuple[str, str]] = [] # (stk, fut)
        self._pair_map: Dict[str, List[Tuple[str, str]]] = {} # Reverse Index: code -> [(stk, fut), ...]
        
        # Connect Execution Event
        self.execution.on_order_callback = self.on_execution_event
        
        self.running = False
        self.last_sync_ts = 0

    def start(self):
        if not self.execution.login():
            return False
        
        self.running = True
        
        # Install Market Data Callbacks
        @self.execution.api.on_bidask_stk_v1(bind=True)
        def _on_stk_callback(self_api, exchange, bidask):
            self.market_data.update_stock(bidask)
            
        @self.execution.api.on_bidask_fop_v1(bind=True)
        def _on_fop_callback(self_api, exchange, bidask):
            self.market_data.update_future(bidask)

        # Initial Sync of Positions
        self._sync_held_positions()
        


        @self.execution.api.on_tick_stk_v1(bind=True)
        def _on_tick_stk_callback(self_api, exchange, tick):
            self.market_data.update_stock(tick)
            
        @self.execution.api.on_tick_fop_v1(bind=True)
        def _on_tick_fop_callback(self_api, exchange, tick):
            self.market_data.update_future(tick)
            
        return True

    def stop(self):
        self.running = False
    
    def discover_and_subscribe(self):
        discovery = PairDiscovery(self.execution.api)
        # Scan for pairs (va3 uses 80, we use 20 for safety in vb01 initially)
        self.monitored_pairs = discovery.scan(limit=20)
        
        # Build Reverse Index for O(1) Lookup
        self._build_pair_map()

    def _sync_held_positions_fast(self):
        """Fast sync without sleep, used in main loop."""
        try:
            pos_map = self.execution.get_all_positions()
            current_held = set()
            for code, qty in pos_map.items():
                if qty != 0:
                    current_held.add(code)
            
            # Update cache (Union with current held to avoid forgetting active ones? 
            # OR Replace? If we replace, we might lose "intent" based holds that aren't filled yet.
            # But get_all_positions reflects REALITY.
            # However, if we just placed an order, it might not be in position yet.
            # So simple Union is safer, or check active_txs.
            # But the user issue is "cache not updated after manual close".
            # If we Replace, we fix that.
            
            # Safe Strategy:
            # held = positions + active_tx.intent.stock_code
            
            recalc_held = current_held.copy()
            with self._lock:
                for tx in self.active_transactions.values():
                    recalc_held.add(tx.intent.stock_code)
            
            self.held_positions = recalc_held
            # print(f"[TxMgr] Sync Fast: {len(self.held_positions)} items")
        except: 
            pass

    def _sync_held_positions(self):
        """Initial population of held_positions set from API."""
        print("[TxMgr] Syncing initial positions (Wait 2s for API)...")
        time.sleep(2.0)
        try:
            # Force update first
            if self.execution.stock_account: 
                self.execution.api.update_status(self.execution.stock_account)
                print("[TxMgr] Stock Account Status Updated.")
            if self.execution.futopt_account:
                self.execution.api.update_status(self.execution.futopt_account)
                print("[TxMgr] Future Account Status Updated.")
                
            pos_map = self.execution.get_all_positions()
            print(f"[TxMgr] Raw Positions Attempt 1: {pos_map}")
            
            # Retry if empty but we expect something (heuristic: wait more)
            if not pos_map:
                 print("[TxMgr] Retrying sync in 2s...")
                 time.sleep(2.0)
                 if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
                 pos_map = self.execution.get_all_positions()
                 print(f"[TxMgr] Raw Positions Attempt 2: {pos_map}")
            
            count = 0
            for code, qty in pos_map.items():
                if qty != 0:
                    self.held_positions.add(code)
                    count += 1
            print(f"[TxMgr] Initial Sync: {count} active positions cached: {self.held_positions}")
        except Exception as e:
            print(f"[TxMgr] Initial Sync Failed: {e}")

    def _build_pair_map(self):
        """
        Builds a reverse index mapping from individual code (Stock or Future) 
        to the list of pairs that contain it.
        """
        self._pair_map.clear()
        for s, f in self.monitored_pairs:
            # Map Stock -> (s, f)
            if s not in self._pair_map: self._pair_map[s] = []
            self._pair_map[s].append((s, f))
            
            # Map Future -> (s, f)
            if f not in self._pair_map: self._pair_map[f] = []
            self._pair_map[f].append((s, f))
            
        print(f"[TxMgr] Indexed {len(self.monitored_pairs)} pairs into {len(self._pair_map)} unique codes.")

        # Subscribe to all pairs
        print(f"[TxMgr] Subscribing to {len(self.monitored_pairs)} pairs...")
        for s, f in self.monitored_pairs:
            # print(f"[TxMgr] Subscribed: {s} <-> {f}")
            c_stk = resolve_stock_contract(self.execution.api, s)
            c_fut = resolve_future_contract(self.execution.api, f)
            
            if not c_stk:
                print(f"[SUBSCRIBE][ERR] Stock contract NOT FOUND: {s}")
            # else:
            #     print(f"[SUBSCRIBE][OK] Stock found: {s}")
                
            if not c_fut:
                print(f"[SUBSCRIBE][ERR] Future contract NOT FOUND: {f}")
            else:
                print(f"[SUBSCRIBE][OK] Future found: {f} -> {c_fut.code}")
            
            if c_stk:
                self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.Tick)
                self.execution.api.quote.subscribe(c_stk, quote_type=sj.constant.QuoteType.BidAsk)
            if c_fut:
                self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.Tick)
                self.execution.api.quote.subscribe(c_fut, quote_type=sj.constant.QuoteType.BidAsk)

    def _on_market_tick(self, code: str):
        """
        Callback triggered by MarketData when price updates.
        Event-Driven Strategy Execution.
        """
        # 1. Fast Lookup (O(1))
        affected_pairs = self._pair_map.get(code)
        if not affected_pairs:
            return

        # 2. Execute Strategy for affected pairs
        for s, f in affected_pairs:
            # Lock is handled inside request_new_transaction for shared state, 
            # but reading active_transactions check effectively needs lock if strict,
            # however, doing a quick check here is optimization.
            # Strategy checks are pure logic + market data (thread safe internal).
            
            # Optimization: Skip if already active (Wait for lock to be sure inside request)
            # But let's check quickly to avoid strategy run
            with self._lock:
                if s in self.active_transactions:
                    continue

            intent = self.strategy.on_tick(s, f)
            if intent:
                self.request_new_transaction(intent)
        

            

    def _check_position_safety(self, intent: TradeIntent) -> bool:
        # Use ExecutionEngine's helper
        positions = self.execution.get_all_positions()
        
        s_qty = positions.get(intent.stock_code, 0)
        f_qty = positions.get(intent.future_code, 0)
        
        if intent.type == SignalType.OPEN:
             # Reject if we already have exposure
             if abs(s_qty) > 0 or abs(f_qty) > 0:
                  print(f"[TxMgr] REJECT OPEN: Existing Position found {intent.stock_code}={s_qty}, {intent.future_code}={f_qty}")
                  return False
        
        elif intent.type == SignalType.CLOSE:
             # Strict Check: Close requires Stock > 0 AND Future < 0 (Arbitrage Position)
             # If we are net Long Future, CLOSE (Buy Future) makes it WORSE.
             if not (s_qty > 0 and f_qty < 0):
                  print(f"[TxMgr] REJECT CLOSE: Position not arbitrage-shape (s={s_qty}, f={f_qty}). Use Repair instead.")
                  # Apply Cooldown to silence noise
                  self.cooldowns[intent.stock_code] = time.time() + 60
                  self.cooldowns[intent.future_code] = time.time() + 60
                  return False
                  
             # Reject if we have NO exposure (Duplicate Close)
             if s_qty == 0 and f_qty == 0:
                  # print(f"[TxMgr] REJECT CLOSE: No Position to close.")
                  return False
                  
        return True

    def request_new_transaction(self, intent: TradeIntent) -> bool:
        with self._lock: # Protect active_transactions
            if intent.stock_code in self.active_transactions:
                return False
                
            # Cooldown check
            for k in (intent.stock_code, intent.future_code):
                 if k in self.cooldowns and time.time() < self.cooldowns[k]:
                     return False
    
            # Safety Check (Positions)
            if not self._check_position_safety(intent):
                 return False
            
            print(f"[TxMgr] ACCEPT: Starting new transaction for {intent.stock_code} ({intent.details})")
            
            # Factory Logic
            if intent.type == SignalType.OPEN:
                tx = OpenArbitrageTransaction(intent, self)
            elif intent.type == SignalType.CLOSE:
                tx = CloseArbitrageTransaction(intent, self)
            else:
                tx = BaseTransaction(intent, self) 
                
            self.active_transactions[intent.stock_code] = tx
            return True

    def run_step(self):
        # 0. Force Status Update (Sim Workaround)
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except: pass

        # 0.5 Periodic Sync (Every 30s)
        if time.time() - self.last_sync_ts > 30:
            self.last_sync_ts = time.time()
            self._sync_held_positions_fast()

        # 0.6 Central Status Line (Every 1s)
        print(f"[Main] Active: {len(self.active_transactions)} | Monitored: {len(self.monitored_pairs)} | {time.strftime('%H:%M:%S')}", end='\r')


        # 1. Update Active Transactions
        with self._lock:
            codes = list(self.active_transactions.keys())
            
        # Iterate copy to avoid holding lock during update() calls which might trigger events or be slow
        # (Though update() acts on Transaction object, which manages its own state, but interacts with execution)
        
        clean_up_list = []
        
        for code in codes:
            # Re-acquire item safely
            with self._lock:
                tx = self.active_transactions.get(code)
            if not tx: continue

            tx.update()
            
            if tx.state in [TransactionState.COMPLETED, TransactionState.FAILED, TransactionState.CANCELLED]:
                print(f"[TxMgr] Archiving Tx {tx.tx_id}")
                self.completed_transactions.append(tx)
                
                # If Failed (Timeout), apply Cooldown to prevent spiral
                if tx.state == TransactionState.FAILED:
                     print(f"[TxMgr] Apply Cooldown (60s) for {code}")
                     with self._lock:
                        self.cooldowns[code] = time.time() + 60
                
                clean_up_list.append(code)

        # Remove dead transactions
        if clean_up_list:
            with self._lock:
                for code in clean_up_list:
                    if code in self.active_transactions:
                        del self.active_transactions[code]

        # 2. Run Strategy (Scanning) -> REMOVED in Event-Driven Mode
        # Strategy is now triggered by _on_market_tick callback.

    def repair_positions(self):
        print("\n[TxMgr] === REPAIRING POSITIONS (Aggressive) ===")
        try:
             if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
             if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
        except: pass

        stk_map = {}
        if self.execution.stock_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.stock_account):
                     stk_map[p.code] = int(p.quantity)
             except: pass
        
        fut_map = {} 
        if self.execution.futopt_account:
             try:
                 for p in self.execution.api.list_positions(self.execution.futopt_account):
                     qty = int(p.quantity)
                     net = qty if p.direction == sj.constant.Action.Buy else -qty
                     fut_map[p.code] = net
             except: pass

        for s, f in self.monitored_pairs:
             s_qty = stk_map.get(s, 0)
             f_net = fut_map.get(f, 0)
             
             # 1. Naked Long Future -> Sell
             if f_net > 0:
                  print(f"[Repair] {f} is Net Long ({f_net}). Closing (Sell)...")
                  self.execution.place_future_order(f, "Sell", 0, abs(f_net), "MKT", "IOC")
             
             # 2. Naked Short Future (No Stock) -> Buy
             elif f_net < 0:
                  if s_qty == 0:
                       print(f"[Repair] {f} is Naked Short ({f_net}). Closing (Buy)...")
                       self.execution.place_future_order(f, "Buy", 0, abs(f_net), "MKT", "IOC")

             # 3. Naked Stock (No Future) -> Sell
             if s_qty > 0 and f_net == 0:
                  print(f"[Repair] {s} is Naked Stock ({s_qty}). Closing (Sell)...")
                  self.execution.place_stock_order(s, "Sell", 0, s_qty, "MKT", "ROD")

        print("[Repair] Scan complete.\n")

    def repair_flatten_unpaired_futures(self, dry_run: bool = True, cooldown_sec: int = 30):
        """
        Flatten futures if stock is 0 and future != 0.
        dry_run=True: only print plan; no orders.
        """
        print(f"\n[TxMgr] Fixing Unpaired Futures... (dry_run={dry_run})")

        # 0) Force refresh
        try:
            if self.execution.stock_account: self.execution.api.update_status(self.execution.stock_account)
            if self.execution.futopt_account: self.execution.api.update_status(self.execution.futopt_account)
            time.sleep(1.0)
        except:
            pass

        # 1) Build holdings
        s_holdings = {}
        if self.execution.stock_account:
            try:
                for p in self.execution.api.list_positions(self.execution.stock_account):
                    s_holdings[p.code] = int(p.quantity)
            except:
                pass

        f_holdings = {}
        if self.execution.futopt_account:
            try:
                for p in self.execution.api.list_positions(self.execution.futopt_account):
                    qty = int(p.quantity)
                    net = qty if p.direction == sj.constant.Action.Buy else -qty
                    f_holdings[p.code] = net
            except:
                pass

        # 2) Flatten
        for s, f in self.monitored_pairs:
            # Sync Cache
            if s_holdings.get(s, 0) != 0:
                self.held_positions.add(s)
            elif s in self.held_positions:
                self.held_positions.remove(s) # No longer held

            s_qty = s_holdings.get(s, 0)
            f_qty = f_holdings.get(f, 0)

            if s_qty != 0 or f_qty == 0:
                continue

            # cooldown per stock (silence repeated repair on same name)
            exp = self.cooldowns.get(s, 0)
            if time.time() < exp:
                continue

            action = "Sell" if f_qty > 0 else "Buy"
            closing_qty = abs(f_qty)

            print(f"[Repair] {s}/{f}: Stock=0, Fut={f_qty} -> {action} {closing_qty} (flatten)")

            # apply cooldown even in dry-run (avoid spam)
            self.cooldowns[s] = time.time() + cooldown_sec

            if dry_run:
                continue

            self.execution.place_future_order(f, action, 0, closing_qty, "MKT", "IOC")

        print("[Repair] Done.\n")
                  
    def on_execution_event(self, oid, seqno, op_code, op_msg, status_data):
        # Update Held Positions if Filled
        if op_code == "00": # Success / Update
             deal_qty = int(status_data.get("deal_quantity", 0))
             if deal_qty > 0:
                 # If we bought/sold something, update our held cache?
                 # Actually, it's safer to just re-sync or track specific fills?
                 # For simplicity, if we get a fill, we re-sync or add to cache.
                 # Re-syncing is expensive (API call).
                 # Let's just rely on active transaction state for now, but for robustness:
                 # If we just filled a STOCK order, we hold it.
                 # (Determining code requires matching seqno, which we do below).
                 pass

        # Dispatch to active transaction
        # Fix 3A: Iterate with snapshot
        found_active = False
        
        with self._lock:
            active_txs = list(self.active_transactions.values())
            
        for tx in active_txs:
            if (tx.stock_order.seqno and tx.stock_order.seqno == seqno):
                 # Update Code Cache if Stock Filled
                 if status_data.get("deal_quantity", 0):
                     self.held_positions.add(tx.intent.stock_code)
                     
                 tx.on_order_update(seqno, op_code, msg=op_msg, status_data=status_data)
                 found_active = True
                 # If Tx Completed (e.g. Closed), remove from held_positions?
                 # Strategy logic: If Held -> Allow Close Log.
                 # If we Closed it, we no longer hold it?
                 # CloseArbitrageTransaction will eventually sell stock.
                 # If Stock is Sold (qty=0), we should remove it.
                 # This is tricky without full accounting.
                 # But "held_positions" is mainly to suppresses Entry Logs.
                 # If we just Closed it, we assume we are flat.
                 # We can remove from held_positions if Tx is DONE?
                 break
            elif (tx.future_order.seqno and tx.future_order.seqno == seqno):
                 tx.on_order_update(seqno, op_code, msg=op_msg, status_data=status_data)
                 found_active = True
                 break
        
        if found_active:
            # Check if Tx finished, if so, maybe remove from held?
            # But checking here is messy. Let's rely on run_step cleanup.
            return
            
        # ... (Late fill logic)

        # Check for Late Fills in Archived Transactions
        # If we receive a Fill for a transaction we already timed out, we must repair.
        deal_qty = int(status_data.get("deal_quantity", 0))
        if deal_qty > 0:
             for tx in self.completed_transactions:
                 if (tx.stock_order.seqno and tx.stock_order.seqno == seqno) or \
                    (tx.future_order.seqno and tx.future_order.seqno == seqno):
                      print(f"\n[TxMgr] ⚠️ CRITICAL: Late Fill detected for Archived Tx {tx.tx_id} (Seq={seqno})!")
                      print(f"[TxMgr] This causes a Naked Position. Triggering Auto-Repair...")
                      self.repair_positions()
                      break

    def dump_status(self) -> str:
        lines = ["\n=== STATUS ==="]
        lines.append(f"Monitored Pairs: {len(self.monitored_pairs)}")
        for s, f in self.monitored_pairs:
            stk_data = self.market_data.get_stock(s)
            fut_data = self.market_data.get_future(f)
            s_price = stk_data.price if stk_data else 0.0
            f_price = fut_data.price if fut_data else 0.0
            
            # Strategy Info
            stat = self.strategy.stats.get((s, f))
            extra = "(No Stats)"
            if stat and stat.samples > 0:
                 spread = f_price - s_price
                 # Access Strategy constants safely
                 min_std = getattr(self.strategy, 'MIN_STD', 1.0)
                 std = max(stat.std, min_std)
                 z = (spread - stat.mean) / std
                 extra = f"Sprd={spread:.1f} Z={z:.2f} (Avg={stat.mean:.1f})"
            
            lines.append(f"  {s}({s_price}) <-> {f}({f_price}) | {extra}")
            
        lines.append(f"\nActive Transactions: {len(self.active_transactions)}")
        for code, tx in self.active_transactions.items():
            lines.append(f"  [{code}] State={tx.state.name} Created={time.strftime('%H:%M:%S', time.localtime(tx.created_at))}")
            lines.append(f"    Leg1: {tx.stock_order.status} ({tx.stock_order.filled_qty}/{tx.intent.qty})")
            lines.append(f"    Leg2: {tx.future_order.status} ({tx.future_order.filled_qty})")

        lines.append(self.execution.dump_positions())
            
        return "\n".join(lines)

# --- Interactive Keyboard ---
try:
    import termios, tty, select
    _HAS_TERMIOS = True
except Exception:
    _HAS_TERMIOS = False

try:
    import msvcrt
    _HAS_MS = True
except Exception:
    _HAS_MS = False

class KeyboardMonitor(threading.Thread):
    """
    p -> print positions / transactions
    o -> print orders
    h -> help
    q -> quit
    x -> repair (close naked positions)
    """
    def __init__(self, manager: 'TransactionManager', poll_sec: float = 0.5):
        super().__init__(daemon=True)
        self.mgr = manager
        self.poll_sec = poll_sec
        self._stop_evt = threading.Event()

    def stop(self):
        self._stop_evt.set()

    def run(self):
        self._print_help_once()
        if _HAS_MS:
            self._run_windows()
        elif _HAS_TERMIOS:
            self._run_posix()
        else:
             print("[Keyboard] No interactive support (no termios/msvcrt).")
             while not self._stop_evt.is_set():
                 time.sleep(1.0)

    def _print_help_once(self):
        print("\n[Keyboard] p=status, o=orders, h=help, q=quit\n", flush=True)

    def _handle_key(self, ch: str):
        # Fix 0C: Do NOT force lower() immediately
        ch = (ch or "").strip()
        if not ch: return
        
        if ch.lower() == "p":
            print(self.mgr.dump_status(), flush=True)
        elif ch.lower() == "o":
            # Assuming dump_orders exists or we implement it
            print(self.mgr.execution.dump_orders(), flush=True) 
        elif ch == "x": # Little x
            print("[Keyboard] 'x' pressed: Running repair (Dry Run requested but Logic is aggressive)...")
            # For vb01, let's assume 'x' is safer or just same.
            self.mgr.repair_positions() 
        elif ch == "X": # Big X
            print("[Keyboard] 'X' pressed: FORCE REPAIR started...")
            self.mgr.repair_positions()
        elif ch == "h":
            self._print_help_once()
        elif ch == "q":
            print("\n[Keyboard] Quit requested...", flush=True)
            self.mgr.stop()
            self.stop()
            # Cancel all open orders before quitting
            print("[Keyboard] Cancelling ALL open orders...", flush=True)
            self.mgr.execution.cancel_all_orders()
            # We might need to interrupt main loop main_stop_event
            # But Main is running via checking mgr.running?
            # We'll set a flag in mgr.
            
    def _run_windows(self):
        while not self._stop_evt.is_set():
            if msvcrt.kbhit():
                ch = msvcrt.getwch()
                self._handle_key(ch)
            time.sleep(self.poll_sec)

    def _run_posix(self):
        fd = sys.stdin.fileno()
        try:
            old = termios.tcgetattr(fd)
        except Exception:
            return

        try:
            tty.setcbreak(fd)
            while not self._stop_evt.is_set():
                r, _, _ = select.select([sys.stdin], [], [], self.poll_sec)
                if r:
                    ch = sys.stdin.read(1)
                    self._handle_key(ch)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old)

# --- Main ---
def main():
    # Setup Logging
    logging.basicConfig(level=logging.WARNING)
    
    mgr = TransactionManager()
    
    # Start System
    if not mgr.start():
        print("[Main] Failed to start system.")
        return

    # Start Keyboard Monitor
    kb = KeyboardMonitor(mgr)
    kb.start()
    
    print("[Main] System Started. Press 'h' for help.")
    
    try:
        # Initial Discovery
        mgr.discover_and_subscribe()
        
        # Main Loop
        loops = 0
        while mgr.running:
            mgr.run_step()
            time.sleep(1.0)
            loops += 1
            if loops % 10 == 0:
                print(f"[Main] Loop {loops}...", end='\r')
                
    except KeyboardInterrupt:
        print("\n[Main] Interrupted.")
    except Exception as e:
        traceback.print_exc()
        print(f"[Main] Error: {e}")
    finally:
        kb.stop()
        print("[Main] Shutdown.")
        
if __name__ == "__main__":
    main()
